// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/keys.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct RPCError {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub details: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RPCError {
    fn default() -> &'a RPCError {
        <RPCError as ::protobuf::Message>::default_instance()
    }
}

impl RPCError {
    pub fn new() -> RPCError {
        ::std::default::Default::default()
    }

    // int32 code = 1;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string details = 3;


    pub fn get_details(&self) -> &str {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.details, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RPCError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.details.is_empty() {
            os.write_string(3, &self.details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPCError {
        RPCError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &RPCError| { &m.code },
                    |m: &mut RPCError| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &RPCError| { &m.message },
                    |m: &mut RPCError| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "details",
                    |m: &RPCError| { &m.details },
                    |m: &mut RPCError| { &mut m.details },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RPCError>(
                    "RPCError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPCError {
        static mut instance: ::protobuf::lazy::Lazy<RPCError> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RPCError::new)
        }
    }
}

impl ::protobuf::Clear for RPCError {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPCError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPCError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignRequest {
    fn default() -> &'a SignRequest {
        <SignRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignRequest {
    pub fn new() -> SignRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignRequest {
        SignRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SignRequest| { &m.data },
                    |m: &mut SignRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signer",
                    |m: &SignRequest| { &m.signer },
                    |m: &mut SignRequest| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &SignRequest| { &m.armored },
                    |m: &mut SignRequest| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "detached",
                    |m: &SignRequest| { &m.detached },
                    |m: &mut SignRequest| { &mut m.detached },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignRequest>(
                    "SignRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignResponse {
    fn default() -> &'a SignResponse {
        <SignResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignResponse {
    pub fn new() -> SignResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignResponse {
        SignResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SignResponse| { &m.data },
                    |m: &mut SignResponse| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &SignResponse| { &m.kid },
                    |m: &mut SignResponse| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignResponse>(
                    "SignResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignFileInput {
    fn default() -> &'a SignFileInput {
        <SignFileInput as ::protobuf::Message>::default_instance()
    }
}

impl SignFileInput {
    pub fn new() -> SignFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignFileInput {
        SignFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &SignFileInput| { &m.field_in },
                    |m: &mut SignFileInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &SignFileInput| { &m.out },
                    |m: &mut SignFileInput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signer",
                    |m: &SignFileInput| { &m.signer },
                    |m: &mut SignFileInput| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &SignFileInput| { &m.armored },
                    |m: &mut SignFileInput| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "detached",
                    |m: &SignFileInput| { &m.detached },
                    |m: &mut SignFileInput| { &mut m.detached },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignFileInput>(
                    "SignFileInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignFileInput {
        static mut instance: ::protobuf::lazy::Lazy<SignFileInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignFileInput::new)
        }
    }
}

impl ::protobuf::Clear for SignFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignFileOutput {
    // message fields
    pub kid: ::std::string::String,
    pub bytes: i32,
    pub total: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignFileOutput {
    fn default() -> &'a SignFileOutput {
        <SignFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl SignFileOutput {
    pub fn new() -> SignFileOutput {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 bytes = 2;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 3;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }
}

impl ::protobuf::Message for SignFileOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.bytes != 0 {
            os.write_int32(2, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(3, self.total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignFileOutput {
        SignFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &SignFileOutput| { &m.kid },
                    |m: &mut SignFileOutput| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bytes",
                    |m: &SignFileOutput| { &m.bytes },
                    |m: &mut SignFileOutput| { &mut m.bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total",
                    |m: &SignFileOutput| { &m.total },
                    |m: &mut SignFileOutput| { &mut m.total },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignFileOutput>(
                    "SignFileOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignFileOutput {
        static mut instance: ::protobuf::lazy::Lazy<SignFileOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignFileOutput::new)
        }
    }
}

impl ::protobuf::Clear for SignFileOutput {
    fn clear(&mut self) {
        self.kid.clear();
        self.bytes = 0;
        self.total = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyRequest {
    fn default() -> &'a VerifyRequest {
        <VerifyRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyRequest {
    pub fn new() -> VerifyRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for VerifyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyRequest {
        VerifyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyRequest| { &m.data },
                    |m: &mut VerifyRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &VerifyRequest| { &m.armored },
                    |m: &mut VerifyRequest| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "detached",
                    |m: &VerifyRequest| { &m.detached },
                    |m: &mut VerifyRequest| { &mut m.detached },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyRequest>(
                    "VerifyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerifyRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerifyRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyResponse {
    fn default() -> &'a VerifyResponse {
        <VerifyResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyResponse {
    pub fn new() -> VerifyResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key signer = 2;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyResponse {
        VerifyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyResponse| { &m.data },
                    |m: &mut VerifyResponse| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "signer",
                    |m: &VerifyResponse| { &m.signer },
                    |m: &mut VerifyResponse| { &mut m.signer },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyResponse>(
                    "VerifyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sig: ::std::vec::Vec<u8>,
    pub armored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedRequest {
    fn default() -> &'a VerifyDetachedRequest {
        <VerifyDetachedRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedRequest {
    pub fn new() -> VerifyDetachedRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }
}

impl ::protobuf::Message for VerifyDetachedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        if self.armored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedRequest {
        VerifyDetachedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyDetachedRequest| { &m.data },
                    |m: &mut VerifyDetachedRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sig",
                    |m: &VerifyDetachedRequest| { &m.sig },
                    |m: &mut VerifyDetachedRequest| { &mut m.sig },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &VerifyDetachedRequest| { &m.armored },
                    |m: &mut VerifyDetachedRequest| { &mut m.armored },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedRequest>(
                    "VerifyDetachedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyDetachedRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerifyDetachedRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyDetachedRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerifyDetachedRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.sig.clear();
        self.armored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedResponse {
    // message fields
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedResponse {
    fn default() -> &'a VerifyDetachedResponse {
        <VerifyDetachedResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedResponse {
    pub fn new() -> VerifyDetachedResponse {
        ::std::default::Default::default()
    }

    // .service.Key signer = 1;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyDetachedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedResponse {
        VerifyDetachedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "signer",
                    |m: &VerifyDetachedResponse| { &m.signer },
                    |m: &mut VerifyDetachedResponse| { &mut m.signer },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedResponse>(
                    "VerifyDetachedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyDetachedResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyDetachedResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyDetachedResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyDetachedResponse {
    fn clear(&mut self) {
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyInput {
    fn default() -> &'a VerifyInput {
        <VerifyInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyInput {
    pub fn new() -> VerifyInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyInput {
        VerifyInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyInput| { &m.data },
                    |m: &mut VerifyInput| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyInput>(
                    "VerifyInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyInput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyInput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyInput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyOutput {
    fn default() -> &'a VerifyOutput {
        <VerifyOutput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyOutput {
    pub fn new() -> VerifyOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key signer = 2;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyOutput {
        VerifyOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyOutput| { &m.data },
                    |m: &mut VerifyOutput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "signer",
                    |m: &VerifyOutput| { &m.signer },
                    |m: &mut VerifyOutput| { &mut m.signer },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyOutput>(
                    "VerifyOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyOutput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyOutput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub armored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyFileInput {
    fn default() -> &'a VerifyFileInput {
        <VerifyFileInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyFileInput {
    pub fn new() -> VerifyFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }
}

impl ::protobuf::Message for VerifyFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.armored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyFileInput {
        VerifyFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &VerifyFileInput| { &m.field_in },
                    |m: &mut VerifyFileInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &VerifyFileInput| { &m.out },
                    |m: &mut VerifyFileInput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &VerifyFileInput| { &m.armored },
                    |m: &mut VerifyFileInput| { &mut m.armored },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyFileInput>(
                    "VerifyFileInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyFileInput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyFileInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyFileInput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.armored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyFileOutput {
    // message fields
    pub signer: ::protobuf::SingularPtrField<Key>,
    pub out: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyFileOutput {
    fn default() -> &'a VerifyFileOutput {
        <VerifyFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyFileOutput {
    pub fn new() -> VerifyFileOutput {
        ::std::default::Default::default()
    }

    // .service.Key signer = 1;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyFileOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyFileOutput {
        VerifyFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "signer",
                    |m: &VerifyFileOutput| { &m.signer },
                    |m: &mut VerifyFileOutput| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &VerifyFileOutput| { &m.out },
                    |m: &mut VerifyFileOutput| { &mut m.out },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyFileOutput>(
                    "VerifyFileOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyFileOutput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyFileOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyFileOutput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyFileOutput {
    fn clear(&mut self) {
        self.signer.clear();
        self.out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub sig: ::std::vec::Vec<u8>,
    pub armored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedFileInput {
    fn default() -> &'a VerifyDetachedFileInput {
        <VerifyDetachedFileInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedFileInput {
    pub fn new() -> VerifyDetachedFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }
}

impl ::protobuf::Message for VerifyDetachedFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        if self.armored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedFileInput {
        VerifyDetachedFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &VerifyDetachedFileInput| { &m.field_in },
                    |m: &mut VerifyDetachedFileInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sig",
                    |m: &VerifyDetachedFileInput| { &m.sig },
                    |m: &mut VerifyDetachedFileInput| { &mut m.sig },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &VerifyDetachedFileInput| { &m.armored },
                    |m: &mut VerifyDetachedFileInput| { &mut m.armored },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedFileInput>(
                    "VerifyDetachedFileInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyDetachedFileInput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyDetachedFileInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyDetachedFileInput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyDetachedFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.sig.clear();
        self.armored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sig: ::std::vec::Vec<u8>,
    pub armored: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedInput {
    fn default() -> &'a VerifyDetachedInput {
        <VerifyDetachedInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedInput {
    pub fn new() -> VerifyDetachedInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }
}

impl ::protobuf::Message for VerifyDetachedInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        if self.armored != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedInput {
        VerifyDetachedInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &VerifyDetachedInput| { &m.data },
                    |m: &mut VerifyDetachedInput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sig",
                    |m: &VerifyDetachedInput| { &m.sig },
                    |m: &mut VerifyDetachedInput| { &mut m.sig },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &VerifyDetachedInput| { &m.armored },
                    |m: &mut VerifyDetachedInput| { &mut m.armored },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedInput>(
                    "VerifyDetachedInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyDetachedInput {
        static mut instance: ::protobuf::lazy::Lazy<VerifyDetachedInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(VerifyDetachedInput::new)
        }
    }
}

impl ::protobuf::Clear for VerifyDetachedInput {
    fn clear(&mut self) {
        self.data.clear();
        self.sig.clear();
        self.armored = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement {
    // message fields
    pub sig: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    pub seq: i32,
    pub prev: ::std::vec::Vec<u8>,
    pub revoke: i32,
    pub timestamp: i64,
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement {
    fn default() -> &'a Statement {
        <Statement as ::protobuf::Message>::default_instance()
    }
}

impl Statement {
    pub fn new() -> Statement {
        ::std::default::Default::default()
    }

    // bytes sig = 1;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 3;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 4;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // bytes prev = 5;


    pub fn get_prev(&self) -> &[u8] {
        &self.prev
    }
    pub fn clear_prev(&mut self) {
        self.prev.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prev
    }

    // Take field
    pub fn take_prev(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prev, ::std::vec::Vec::new())
    }

    // int32 revoke = 6;


    pub fn get_revoke(&self) -> i32 {
        self.revoke
    }
    pub fn clear_revoke(&mut self) {
        self.revoke = 0;
    }

    // Param is passed by value, moved
    pub fn set_revoke(&mut self, v: i32) {
        self.revoke = v;
    }

    // int64 timestamp = 7;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string type = 8;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Statement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prev)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.revoke = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sig);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prev.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.prev);
        }
        if self.revoke != 0 {
            my_size += ::protobuf::rt::value_size(6, self.revoke, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sig.is_empty() {
            os.write_bytes(1, &self.sig)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(3, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(4, self.seq)?;
        }
        if !self.prev.is_empty() {
            os.write_bytes(5, &self.prev)?;
        }
        if self.revoke != 0 {
            os.write_int32(6, self.revoke)?;
        }
        if self.timestamp != 0 {
            os.write_int64(7, self.timestamp)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(8, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement {
        Statement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sig",
                    |m: &Statement| { &m.sig },
                    |m: &mut Statement| { &mut m.sig },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Statement| { &m.data },
                    |m: &mut Statement| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &Statement| { &m.kid },
                    |m: &mut Statement| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seq",
                    |m: &Statement| { &m.seq },
                    |m: &mut Statement| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "prev",
                    |m: &Statement| { &m.prev },
                    |m: &mut Statement| { &mut m.prev },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "revoke",
                    |m: &Statement| { &m.revoke },
                    |m: &mut Statement| { &mut m.revoke },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &Statement| { &m.timestamp },
                    |m: &mut Statement| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Statement| { &m.field_type },
                    |m: &mut Statement| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Statement>(
                    "Statement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement {
        static mut instance: ::protobuf::lazy::Lazy<Statement> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Statement::new)
        }
    }
}

impl ::protobuf::Clear for Statement {
    fn clear(&mut self) {
        self.sig.clear();
        self.data.clear();
        self.kid.clear();
        self.seq = 0;
        self.prev.clear();
        self.revoke = 0;
        self.timestamp = 0;
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SigchainRequest {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SigchainRequest {
    fn default() -> &'a SigchainRequest {
        <SigchainRequest as ::protobuf::Message>::default_instance()
    }
}

impl SigchainRequest {
    pub fn new() -> SigchainRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SigchainRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SigchainRequest {
        SigchainRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &SigchainRequest| { &m.kid },
                    |m: &mut SigchainRequest| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SigchainRequest>(
                    "SigchainRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SigchainRequest {
        static mut instance: ::protobuf::lazy::Lazy<SigchainRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SigchainRequest::new)
        }
    }
}

impl ::protobuf::Clear for SigchainRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SigchainRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigchainRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SigchainResponse {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    pub statements: ::protobuf::RepeatedField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SigchainResponse {
    fn default() -> &'a SigchainResponse {
        <SigchainResponse as ::protobuf::Message>::default_instance()
    }
}

impl SigchainResponse {
    pub fn new() -> SigchainResponse {
        ::std::default::Default::default()
    }

    // .service.Key key = 1;


    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }

    // repeated .service.Statement statements = 2;


    pub fn get_statements(&self) -> &[Statement] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<Statement>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<Statement> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<Statement> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SigchainResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SigchainResponse {
        SigchainResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "key",
                    |m: &SigchainResponse| { &m.key },
                    |m: &mut SigchainResponse| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statements",
                    |m: &SigchainResponse| { &m.statements },
                    |m: &mut SigchainResponse| { &mut m.statements },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SigchainResponse>(
                    "SigchainResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SigchainResponse {
        static mut instance: ::protobuf::lazy::Lazy<SigchainResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SigchainResponse::new)
        }
    }
}

impl ::protobuf::Clear for SigchainResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.statements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SigchainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigchainResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRequest {
    // message fields
    pub kid: ::std::string::String,
    pub seq: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRequest {
    fn default() -> &'a StatementRequest {
        <StatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementRequest {
    pub fn new() -> StatementRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 2;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }
}

impl ::protobuf::Message for StatementRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(2, self.seq)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRequest {
        StatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &StatementRequest| { &m.kid },
                    |m: &mut StatementRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seq",
                    |m: &StatementRequest| { &m.seq },
                    |m: &mut StatementRequest| { &mut m.seq },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRequest>(
                    "StatementRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatementRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatementRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.seq = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementResponse {
    fn default() -> &'a StatementResponse {
        <StatementResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementResponse {
    pub fn new() -> StatementResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementResponse {
        StatementResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &StatementResponse| { &m.statement },
                    |m: &mut StatementResponse| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementResponse>(
                    "StatementResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatementResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatementResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementCreateRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementCreateRequest {
    fn default() -> &'a StatementCreateRequest {
        <StatementCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementCreateRequest {
    pub fn new() -> StatementCreateRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for StatementCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementCreateRequest {
        StatementCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &StatementCreateRequest| { &m.data },
                    |m: &mut StatementCreateRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &StatementCreateRequest| { &m.kid },
                    |m: &mut StatementCreateRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &StatementCreateRequest| { &m.local },
                    |m: &mut StatementCreateRequest| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementCreateRequest>(
                    "StatementCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatementCreateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementCreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatementCreateRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementCreateResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementCreateResponse {
    fn default() -> &'a StatementCreateResponse {
        <StatementCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementCreateResponse {
    pub fn new() -> StatementCreateResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementCreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementCreateResponse {
        StatementCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &StatementCreateResponse| { &m.statement },
                    |m: &mut StatementCreateResponse| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementCreateResponse>(
                    "StatementCreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementCreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatementCreateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementCreateResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatementCreateResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRevokeRequest {
    // message fields
    pub seq: i32,
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRevokeRequest {
    fn default() -> &'a StatementRevokeRequest {
        <StatementRevokeRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementRevokeRequest {
    pub fn new() -> StatementRevokeRequest {
        ::std::default::Default::default()
    }

    // int32 seq = 1;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for StatementRevokeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.seq != 0 {
            os.write_int32(1, self.seq)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRevokeRequest {
        StatementRevokeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seq",
                    |m: &StatementRevokeRequest| { &m.seq },
                    |m: &mut StatementRevokeRequest| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &StatementRevokeRequest| { &m.kid },
                    |m: &mut StatementRevokeRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &StatementRevokeRequest| { &m.local },
                    |m: &mut StatementRevokeRequest| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRevokeRequest>(
                    "StatementRevokeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementRevokeRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatementRevokeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementRevokeRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatementRevokeRequest {
    fn clear(&mut self) {
        self.seq = 0;
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRevokeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRevokeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRevokeResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRevokeResponse {
    fn default() -> &'a StatementRevokeResponse {
        <StatementRevokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementRevokeResponse {
    pub fn new() -> StatementRevokeResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementRevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRevokeResponse {
        StatementRevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &StatementRevokeResponse| { &m.statement },
                    |m: &mut StatementRevokeResponse| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRevokeResponse>(
                    "StatementRevokeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatementRevokeResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatementRevokeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StatementRevokeResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatementRevokeResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRevokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignInput {
    fn default() -> &'a SignInput {
        <SignInput as ::protobuf::Message>::default_instance()
    }
}

impl SignInput {
    pub fn new() -> SignInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string in = 2;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 3;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.out);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.field_in.is_empty() {
            os.write_string(2, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(3, &self.out)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignInput {
        SignInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SignInput| { &m.data },
                    |m: &mut SignInput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &SignInput| { &m.field_in },
                    |m: &mut SignInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &SignInput| { &m.out },
                    |m: &mut SignInput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signer",
                    |m: &SignInput| { &m.signer },
                    |m: &mut SignInput| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &SignInput| { &m.armored },
                    |m: &mut SignInput| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "detached",
                    |m: &SignInput| { &m.detached },
                    |m: &mut SignInput| { &mut m.detached },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignInput>(
                    "SignInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignInput {
        static mut instance: ::protobuf::lazy::Lazy<SignInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignInput::new)
        }
    }
}

impl ::protobuf::Clear for SignInput {
    fn clear(&mut self) {
        self.data.clear();
        self.field_in.clear();
        self.out.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignOutput {
    fn default() -> &'a SignOutput {
        <SignOutput as ::protobuf::Message>::default_instance()
    }
}

impl SignOutput {
    pub fn new() -> SignOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignOutput {
        SignOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SignOutput| { &m.data },
                    |m: &mut SignOutput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &SignOutput| { &m.kid },
                    |m: &mut SignOutput| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignOutput>(
                    "SignOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignOutput {
        static mut instance: ::protobuf::lazy::Lazy<SignOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignOutput::new)
        }
    }
}

impl ::protobuf::Clear for SignOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub armored: bool,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptRequest {
    fn default() -> &'a EncryptRequest {
        <EncryptRequest as ::protobuf::Message>::default_instance()
    }
}

impl EncryptRequest {
    pub fn new() -> EncryptRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // repeated string recipients = 11;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 12;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptMode mode = 13;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for EncryptRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.armored != false {
            my_size += 2;
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.sender);
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            my_size += ::protobuf::rt::enum_size(13, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        for v in &self.recipients {
            os.write_string(11, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(12, &self.sender)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            os.write_enum(13, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptRequest {
        EncryptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &EncryptRequest| { &m.data },
                    |m: &mut EncryptRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &EncryptRequest| { &m.armored },
                    |m: &mut EncryptRequest| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipients",
                    |m: &EncryptRequest| { &m.recipients },
                    |m: &mut EncryptRequest| { &mut m.recipients },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &EncryptRequest| { &m.sender },
                    |m: &mut EncryptRequest| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                    "mode",
                    |m: &EncryptRequest| { &m.mode },
                    |m: &mut EncryptRequest| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptRequest>(
                    "EncryptRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptRequest {
        static mut instance: ::protobuf::lazy::Lazy<EncryptRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptRequest::new)
        }
    }
}

impl ::protobuf::Clear for EncryptRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.armored = false;
        self.recipients.clear();
        self.sender.clear();
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptResponse {
    fn default() -> &'a EncryptResponse {
        <EncryptResponse as ::protobuf::Message>::default_instance()
    }
}

impl EncryptResponse {
    pub fn new() -> EncryptResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptResponse {
        EncryptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &EncryptResponse| { &m.data },
                    |m: &mut EncryptResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptResponse>(
                    "EncryptResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptResponse {
        static mut instance: ::protobuf::lazy::Lazy<EncryptResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptResponse::new)
        }
    }
}

impl ::protobuf::Clear for EncryptResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub armored: bool,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptFileInput {
    fn default() -> &'a EncryptFileInput {
        <EncryptFileInput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptFileInput {
    pub fn new() -> EncryptFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // repeated string recipients = 11;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 12;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptMode mode = 13;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for EncryptFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.armored != false {
            my_size += 2;
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.sender);
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            my_size += ::protobuf::rt::enum_size(13, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        for v in &self.recipients {
            os.write_string(11, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(12, &self.sender)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            os.write_enum(13, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptFileInput {
        EncryptFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &EncryptFileInput| { &m.field_in },
                    |m: &mut EncryptFileInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &EncryptFileInput| { &m.out },
                    |m: &mut EncryptFileInput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &EncryptFileInput| { &m.armored },
                    |m: &mut EncryptFileInput| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipients",
                    |m: &EncryptFileInput| { &m.recipients },
                    |m: &mut EncryptFileInput| { &mut m.recipients },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &EncryptFileInput| { &m.sender },
                    |m: &mut EncryptFileInput| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                    "mode",
                    |m: &EncryptFileInput| { &m.mode },
                    |m: &mut EncryptFileInput| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptFileInput>(
                    "EncryptFileInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptFileInput {
        static mut instance: ::protobuf::lazy::Lazy<EncryptFileInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptFileInput::new)
        }
    }
}

impl ::protobuf::Clear for EncryptFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.armored = false;
        self.recipients.clear();
        self.sender.clear();
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptFileOutput {
    // message fields
    pub bytes: i32,
    pub total: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptFileOutput {
    fn default() -> &'a EncryptFileOutput {
        <EncryptFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptFileOutput {
    pub fn new() -> EncryptFileOutput {
        ::std::default::Default::default()
    }

    // int32 bytes = 1;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 2;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }
}

impl ::protobuf::Message for EncryptFileOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bytes != 0 {
            os.write_int32(1, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(2, self.total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptFileOutput {
        EncryptFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bytes",
                    |m: &EncryptFileOutput| { &m.bytes },
                    |m: &mut EncryptFileOutput| { &mut m.bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total",
                    |m: &EncryptFileOutput| { &m.total },
                    |m: &mut EncryptFileOutput| { &mut m.total },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptFileOutput>(
                    "EncryptFileOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptFileOutput {
        static mut instance: ::protobuf::lazy::Lazy<EncryptFileOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptFileOutput::new)
        }
    }
}

impl ::protobuf::Clear for EncryptFileOutput {
    fn clear(&mut self) {
        self.bytes = 0;
        self.total = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub armored: bool,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptInput {
    fn default() -> &'a EncryptInput {
        <EncryptInput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptInput {
    pub fn new() -> EncryptInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool armored = 2;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // repeated string recipients = 3;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 4;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptMode mode = 5;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for EncryptInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.armored != false {
            my_size += 2;
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sender);
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            my_size += ::protobuf::rt::enum_size(5, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.armored != false {
            os.write_bool(2, self.armored)?;
        }
        for v in &self.recipients {
            os.write_string(3, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(4, &self.sender)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            os.write_enum(5, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptInput {
        EncryptInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &EncryptInput| { &m.data },
                    |m: &mut EncryptInput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &EncryptInput| { &m.armored },
                    |m: &mut EncryptInput| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipients",
                    |m: &EncryptInput| { &m.recipients },
                    |m: &mut EncryptInput| { &mut m.recipients },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &EncryptInput| { &m.sender },
                    |m: &mut EncryptInput| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                    "mode",
                    |m: &EncryptInput| { &m.mode },
                    |m: &mut EncryptInput| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptInput>(
                    "EncryptInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptInput {
        static mut instance: ::protobuf::lazy::Lazy<EncryptInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptInput::new)
        }
    }
}

impl ::protobuf::Clear for EncryptInput {
    fn clear(&mut self) {
        self.data.clear();
        self.armored = false;
        self.recipients.clear();
        self.sender.clear();
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptOutput {
    fn default() -> &'a EncryptOutput {
        <EncryptOutput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptOutput {
    pub fn new() -> EncryptOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptOutput {
        EncryptOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &EncryptOutput| { &m.data },
                    |m: &mut EncryptOutput| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptOutput>(
                    "EncryptOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptOutput {
        static mut instance: ::protobuf::lazy::Lazy<EncryptOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EncryptOutput::new)
        }
    }
}

impl ::protobuf::Clear for EncryptOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub armored: bool,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptRequest {
    fn default() -> &'a DecryptRequest {
        <DecryptRequest as ::protobuf::Message>::default_instance()
    }
}

impl DecryptRequest {
    pub fn new() -> DecryptRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // .service.EncryptMode mode = 13;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for DecryptRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            my_size += ::protobuf::rt::enum_size(13, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            os.write_enum(13, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptRequest {
        DecryptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DecryptRequest| { &m.data },
                    |m: &mut DecryptRequest| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &DecryptRequest| { &m.armored },
                    |m: &mut DecryptRequest| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                    "mode",
                    |m: &DecryptRequest| { &m.mode },
                    |m: &mut DecryptRequest| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptRequest>(
                    "DecryptRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptRequest {
        static mut instance: ::protobuf::lazy::Lazy<DecryptRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptRequest::new)
        }
    }
}

impl ::protobuf::Clear for DecryptRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.armored = false;
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sender: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptResponse {
    fn default() -> &'a DecryptResponse {
        <DecryptResponse as ::protobuf::Message>::default_instance()
    }
}

impl DecryptResponse {
    pub fn new() -> DecryptResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for DecryptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptResponse {
        DecryptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DecryptResponse| { &m.data },
                    |m: &mut DecryptResponse| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "sender",
                    |m: &DecryptResponse| { &m.sender },
                    |m: &mut DecryptResponse| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptResponse>(
                    "DecryptResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptResponse {
        static mut instance: ::protobuf::lazy::Lazy<DecryptResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptResponse::new)
        }
    }
}

impl ::protobuf::Clear for DecryptResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub armored: bool,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptFileInput {
    fn default() -> &'a DecryptFileInput {
        <DecryptFileInput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptFileInput {
    pub fn new() -> DecryptFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // .service.EncryptMode mode = 13;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for DecryptFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            my_size += ::protobuf::rt::enum_size(13, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT_MODE {
            os.write_enum(13, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptFileInput {
        DecryptFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "in",
                    |m: &DecryptFileInput| { &m.field_in },
                    |m: &mut DecryptFileInput| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &DecryptFileInput| { &m.out },
                    |m: &mut DecryptFileInput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armored",
                    |m: &DecryptFileInput| { &m.armored },
                    |m: &mut DecryptFileInput| { &mut m.armored },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                    "mode",
                    |m: &DecryptFileInput| { &m.mode },
                    |m: &mut DecryptFileInput| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptFileInput>(
                    "DecryptFileInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptFileInput {
        static mut instance: ::protobuf::lazy::Lazy<DecryptFileInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptFileInput::new)
        }
    }
}

impl ::protobuf::Clear for DecryptFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.armored = false;
        self.mode = EncryptMode::DEFAULT_ENCRYPT_MODE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptFileOutput {
    // message fields
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub out: ::std::string::String,
    pub bytes: i32,
    pub total: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptFileOutput {
    fn default() -> &'a DecryptFileOutput {
        <DecryptFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptFileOutput {
    pub fn new() -> DecryptFileOutput {
        ::std::default::Default::default()
    }

    // .service.Key sender = 1;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // int32 bytes = 3;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 4;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }
}

impl ::protobuf::Message for DecryptFileOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.bytes != 0 {
            os.write_int32(3, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(4, self.total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptFileOutput {
        DecryptFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "sender",
                    |m: &DecryptFileOutput| { &m.sender },
                    |m: &mut DecryptFileOutput| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "out",
                    |m: &DecryptFileOutput| { &m.out },
                    |m: &mut DecryptFileOutput| { &mut m.out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bytes",
                    |m: &DecryptFileOutput| { &m.bytes },
                    |m: &mut DecryptFileOutput| { &mut m.bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total",
                    |m: &DecryptFileOutput| { &m.total },
                    |m: &mut DecryptFileOutput| { &mut m.total },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptFileOutput>(
                    "DecryptFileOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptFileOutput {
        static mut instance: ::protobuf::lazy::Lazy<DecryptFileOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptFileOutput::new)
        }
    }
}

impl ::protobuf::Clear for DecryptFileOutput {
    fn clear(&mut self) {
        self.sender.clear();
        self.out.clear();
        self.bytes = 0;
        self.total = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptInput {
    fn default() -> &'a DecryptInput {
        <DecryptInput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptInput {
    pub fn new() -> DecryptInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DecryptInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptInput {
        DecryptInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DecryptInput| { &m.data },
                    |m: &mut DecryptInput| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptInput>(
                    "DecryptInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptInput {
        static mut instance: ::protobuf::lazy::Lazy<DecryptInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptInput::new)
        }
    }
}

impl ::protobuf::Clear for DecryptInput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sender: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptOutput {
    fn default() -> &'a DecryptOutput {
        <DecryptOutput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptOutput {
    pub fn new() -> DecryptOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for DecryptOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptOutput {
        DecryptOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &DecryptOutput| { &m.data },
                    |m: &mut DecryptOutput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "sender",
                    |m: &DecryptOutput| { &m.sender },
                    |m: &mut DecryptOutput| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptOutput>(
                    "DecryptOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecryptOutput {
        static mut instance: ::protobuf::lazy::Lazy<DecryptOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DecryptOutput::new)
        }
    }
}

impl ::protobuf::Clear for DecryptOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeStatusRequest {
    fn default() -> &'a RuntimeStatusRequest {
        <RuntimeStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeStatusRequest {
    pub fn new() -> RuntimeStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RuntimeStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeStatusRequest {
        RuntimeStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeStatusRequest>(
                    "RuntimeStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeStatusRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RuntimeStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeStatusResponse {
    // message fields
    pub version: ::std::string::String,
    pub appName: ::std::string::String,
    pub exe: ::std::string::String,
    pub authSetupNeeded: bool,
    pub fido2: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeStatusResponse {
    fn default() -> &'a RuntimeStatusResponse {
        <RuntimeStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeStatusResponse {
    pub fn new() -> RuntimeStatusResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string appName = 2;


    pub fn get_appName(&self) -> &str {
        &self.appName
    }
    pub fn clear_appName(&mut self) {
        self.appName.clear();
    }

    // Param is passed by value, moved
    pub fn set_appName(&mut self, v: ::std::string::String) {
        self.appName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appName(&mut self) -> &mut ::std::string::String {
        &mut self.appName
    }

    // Take field
    pub fn take_appName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appName, ::std::string::String::new())
    }

    // string exe = 4;


    pub fn get_exe(&self) -> &str {
        &self.exe
    }
    pub fn clear_exe(&mut self) {
        self.exe.clear();
    }

    // Param is passed by value, moved
    pub fn set_exe(&mut self, v: ::std::string::String) {
        self.exe = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exe(&mut self) -> &mut ::std::string::String {
        &mut self.exe
    }

    // Take field
    pub fn take_exe(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exe, ::std::string::String::new())
    }

    // bool authSetupNeeded = 5;


    pub fn get_authSetupNeeded(&self) -> bool {
        self.authSetupNeeded
    }
    pub fn clear_authSetupNeeded(&mut self) {
        self.authSetupNeeded = false;
    }

    // Param is passed by value, moved
    pub fn set_authSetupNeeded(&mut self, v: bool) {
        self.authSetupNeeded = v;
    }

    // bool fido2 = 6;


    pub fn get_fido2(&self) -> bool {
        self.fido2
    }
    pub fn clear_fido2(&mut self) {
        self.fido2 = false;
    }

    // Param is passed by value, moved
    pub fn set_fido2(&mut self, v: bool) {
        self.fido2 = v;
    }
}

impl ::protobuf::Message for RuntimeStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exe)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authSetupNeeded = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fido2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.appName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.appName);
        }
        if !self.exe.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.exe);
        }
        if self.authSetupNeeded != false {
            my_size += 2;
        }
        if self.fido2 != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.appName.is_empty() {
            os.write_string(2, &self.appName)?;
        }
        if !self.exe.is_empty() {
            os.write_string(4, &self.exe)?;
        }
        if self.authSetupNeeded != false {
            os.write_bool(5, self.authSetupNeeded)?;
        }
        if self.fido2 != false {
            os.write_bool(6, self.fido2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeStatusResponse {
        RuntimeStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &RuntimeStatusResponse| { &m.version },
                    |m: &mut RuntimeStatusResponse| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "appName",
                    |m: &RuntimeStatusResponse| { &m.appName },
                    |m: &mut RuntimeStatusResponse| { &mut m.appName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exe",
                    |m: &RuntimeStatusResponse| { &m.exe },
                    |m: &mut RuntimeStatusResponse| { &mut m.exe },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "authSetupNeeded",
                    |m: &RuntimeStatusResponse| { &m.authSetupNeeded },
                    |m: &mut RuntimeStatusResponse| { &mut m.authSetupNeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "fido2",
                    |m: &RuntimeStatusResponse| { &m.fido2 },
                    |m: &mut RuntimeStatusResponse| { &mut m.fido2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeStatusResponse>(
                    "RuntimeStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeStatusResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RuntimeStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeStatusResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.appName.clear();
        self.exe.clear();
        self.authSetupNeeded = false;
        self.fido2 = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthSetupRequest {
    // message fields
    pub password: ::std::string::String,
    pub client: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthSetupRequest {
    fn default() -> &'a AuthSetupRequest {
        <AuthSetupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthSetupRequest {
    pub fn new() -> AuthSetupRequest {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string client = 6;


    pub fn get_client(&self) -> &str {
        &self.client
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        &mut self.client
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthSetupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        if !self.client.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        if !self.client.is_empty() {
            os.write_string(6, &self.client)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthSetupRequest {
        AuthSetupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AuthSetupRequest| { &m.password },
                    |m: &mut AuthSetupRequest| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client",
                    |m: &AuthSetupRequest| { &m.client },
                    |m: &mut AuthSetupRequest| { &mut m.client },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthSetupRequest>(
                    "AuthSetupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthSetupRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthSetupRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthSetupRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthSetupRequest {
    fn clear(&mut self) {
        self.password.clear();
        self.client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthSetupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSetupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthSetupResponse {
    // message fields
    pub authToken: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthSetupResponse {
    fn default() -> &'a AuthSetupResponse {
        <AuthSetupResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthSetupResponse {
    pub fn new() -> AuthSetupResponse {
        ::std::default::Default::default()
    }

    // string authToken = 1;


    pub fn get_authToken(&self) -> &str {
        &self.authToken
    }
    pub fn clear_authToken(&mut self) {
        self.authToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_authToken(&mut self, v: ::std::string::String) {
        self.authToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authToken(&mut self) -> &mut ::std::string::String {
        &mut self.authToken
    }

    // Take field
    pub fn take_authToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authToken, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthSetupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authToken.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.authToken.is_empty() {
            os.write_string(1, &self.authToken)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthSetupResponse {
        AuthSetupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "authToken",
                    |m: &AuthSetupResponse| { &m.authToken },
                    |m: &mut AuthSetupResponse| { &mut m.authToken },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthSetupResponse>(
                    "AuthSetupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthSetupResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthSetupResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthSetupResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthSetupResponse {
    fn clear(&mut self) {
        self.authToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthSetupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSetupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUnlockRequest {
    // message fields
    pub password: ::std::string::String,
    pub client: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUnlockRequest {
    fn default() -> &'a AuthUnlockRequest {
        <AuthUnlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUnlockRequest {
    pub fn new() -> AuthUnlockRequest {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string client = 2;


    pub fn get_client(&self) -> &str {
        &self.client
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        &mut self.client
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUnlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        if !self.client.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        if !self.client.is_empty() {
            os.write_string(2, &self.client)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUnlockRequest {
        AuthUnlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AuthUnlockRequest| { &m.password },
                    |m: &mut AuthUnlockRequest| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client",
                    |m: &AuthUnlockRequest| { &m.client },
                    |m: &mut AuthUnlockRequest| { &mut m.client },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUnlockRequest>(
                    "AuthUnlockRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUnlockRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUnlockRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthUnlockRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUnlockRequest {
    fn clear(&mut self) {
        self.password.clear();
        self.client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUnlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUnlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUnlockResponse {
    // message fields
    pub authToken: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUnlockResponse {
    fn default() -> &'a AuthUnlockResponse {
        <AuthUnlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUnlockResponse {
    pub fn new() -> AuthUnlockResponse {
        ::std::default::Default::default()
    }

    // string authToken = 1;


    pub fn get_authToken(&self) -> &str {
        &self.authToken
    }
    pub fn clear_authToken(&mut self) {
        self.authToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_authToken(&mut self, v: ::std::string::String) {
        self.authToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authToken(&mut self) -> &mut ::std::string::String {
        &mut self.authToken
    }

    // Take field
    pub fn take_authToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authToken, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUnlockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authToken.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.authToken.is_empty() {
            os.write_string(1, &self.authToken)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUnlockResponse {
        AuthUnlockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "authToken",
                    |m: &AuthUnlockResponse| { &m.authToken },
                    |m: &mut AuthUnlockResponse| { &mut m.authToken },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUnlockResponse>(
                    "AuthUnlockResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUnlockResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUnlockResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthUnlockResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUnlockResponse {
    fn clear(&mut self) {
        self.authToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUnlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUnlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthLockRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthLockRequest {
    fn default() -> &'a AuthLockRequest {
        <AuthLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthLockRequest {
    pub fn new() -> AuthLockRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthLockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthLockRequest {
        AuthLockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthLockRequest>(
                    "AuthLockRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthLockRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthLockRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthLockRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthLockRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthLockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthLockResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthLockResponse {
    fn default() -> &'a AuthLockResponse {
        <AuthLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthLockResponse {
    pub fn new() -> AuthLockResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthLockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthLockResponse {
        AuthLockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthLockResponse>(
                    "AuthLockResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthLockResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthLockResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AuthLockResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthLockResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthLockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyGenerateRequest {
    // message fields
    pub field_type: KeyType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyGenerateRequest {
    fn default() -> &'a KeyGenerateRequest {
        <KeyGenerateRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyGenerateRequest {
    pub fn new() -> KeyGenerateRequest {
        ::std::default::Default::default()
    }

    // .service.KeyType type = 1;


    pub fn get_field_type(&self) -> KeyType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = KeyType::UNKNOWN_KEY_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: KeyType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for KeyGenerateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != KeyType::UNKNOWN_KEY_TYPE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != KeyType::UNKNOWN_KEY_TYPE {
            os.write_enum(1, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyGenerateRequest {
        KeyGenerateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyType>>(
                    "type",
                    |m: &KeyGenerateRequest| { &m.field_type },
                    |m: &mut KeyGenerateRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyGenerateRequest>(
                    "KeyGenerateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyGenerateRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeyGenerateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyGenerateRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeyGenerateRequest {
    fn clear(&mut self) {
        self.field_type = KeyType::UNKNOWN_KEY_TYPE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyGenerateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyGenerateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyGenerateResponse {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyGenerateResponse {
    fn default() -> &'a KeyGenerateResponse {
        <KeyGenerateResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyGenerateResponse {
    pub fn new() -> KeyGenerateResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyGenerateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyGenerateResponse {
        KeyGenerateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &KeyGenerateResponse| { &m.kid },
                    |m: &mut KeyGenerateResponse| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyGenerateResponse>(
                    "KeyGenerateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyGenerateResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeyGenerateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyGenerateResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeyGenerateResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyGenerateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyGenerateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserServiceRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserServiceRequest {
    fn default() -> &'a UserServiceRequest {
        <UserServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserServiceRequest {
    pub fn new() -> UserServiceRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserServiceRequest {
        UserServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &UserServiceRequest| { &m.kid },
                    |m: &mut UserServiceRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &UserServiceRequest| { &m.service },
                    |m: &mut UserServiceRequest| { &mut m.service },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserServiceRequest>(
                    "UserServiceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserServiceRequest {
        static mut instance: ::protobuf::lazy::Lazy<UserServiceRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserServiceRequest::new)
        }
    }
}

impl ::protobuf::Clear for UserServiceRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserServiceResponse {
    // message fields
    pub service: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserServiceResponse {
    fn default() -> &'a UserServiceResponse {
        <UserServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserServiceResponse {
    pub fn new() -> UserServiceResponse {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserServiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserServiceResponse {
        UserServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &UserServiceResponse| { &m.service },
                    |m: &mut UserServiceResponse| { &mut m.service },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserServiceResponse>(
                    "UserServiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserServiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<UserServiceResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserServiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for UserServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSignRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSignRequest {
    fn default() -> &'a UserSignRequest {
        <UserSignRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserSignRequest {
    pub fn new() -> UserSignRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserSignRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSignRequest {
        UserSignRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &UserSignRequest| { &m.kid },
                    |m: &mut UserSignRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &UserSignRequest| { &m.service },
                    |m: &mut UserSignRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &UserSignRequest| { &m.name },
                    |m: &mut UserSignRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSignRequest>(
                    "UserSignRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserSignRequest {
        static mut instance: ::protobuf::lazy::Lazy<UserSignRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserSignRequest::new)
        }
    }
}

impl ::protobuf::Clear for UserSignRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSignRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSignRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSignResponse {
    // message fields
    pub message: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSignResponse {
    fn default() -> &'a UserSignResponse {
        <UserSignResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserSignResponse {
    pub fn new() -> UserSignResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserSignResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSignResponse {
        UserSignResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &UserSignResponse| { &m.message },
                    |m: &mut UserSignResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &UserSignResponse| { &m.name },
                    |m: &mut UserSignResponse| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSignResponse>(
                    "UserSignResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserSignResponse {
        static mut instance: ::protobuf::lazy::Lazy<UserSignResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserSignResponse::new)
        }
    }
}

impl ::protobuf::Clear for UserSignResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSignResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSignResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAddRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    pub url: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAddRequest {
    fn default() -> &'a UserAddRequest {
        <UserAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserAddRequest {
    pub fn new() -> UserAddRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAddRequest {
        UserAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &UserAddRequest| { &m.kid },
                    |m: &mut UserAddRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &UserAddRequest| { &m.service },
                    |m: &mut UserAddRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &UserAddRequest| { &m.name },
                    |m: &mut UserAddRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &UserAddRequest| { &m.url },
                    |m: &mut UserAddRequest| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &UserAddRequest| { &m.local },
                    |m: &mut UserAddRequest| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAddRequest>(
                    "UserAddRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserAddRequest {
        static mut instance: ::protobuf::lazy::Lazy<UserAddRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserAddRequest::new)
        }
    }
}

impl ::protobuf::Clear for UserAddRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.name.clear();
        self.url.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAddResponse {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAddResponse {
    fn default() -> &'a UserAddResponse {
        <UserAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserAddResponse {
    pub fn new() -> UserAddResponse {
        ::std::default::Default::default()
    }

    // .service.User user = 1;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // .service.Statement statement = 2;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for UserAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAddResponse {
        UserAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &UserAddResponse| { &m.user },
                    |m: &mut UserAddResponse| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &UserAddResponse| { &m.statement },
                    |m: &mut UserAddResponse| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAddResponse>(
                    "UserAddResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserAddResponse {
        static mut instance: ::protobuf::lazy::Lazy<UserAddResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserAddResponse::new)
        }
    }
}

impl ::protobuf::Clear for UserAddResponse {
    fn clear(&mut self) {
        self.user.clear();
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyExportRequest {
    // message fields
    pub kid: ::std::string::String,
    pub password: ::std::string::String,
    pub field_type: ExportType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyExportRequest {
    fn default() -> &'a KeyExportRequest {
        <KeyExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyExportRequest {
    pub fn new() -> KeyExportRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // .service.ExportType type = 3;


    pub fn get_field_type(&self) -> ExportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ExportType::DEFAULT_EXPORT_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ExportType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for KeyExportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if self.field_type != ExportType::DEFAULT_EXPORT_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if self.field_type != ExportType::DEFAULT_EXPORT_TYPE {
            os.write_enum(3, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyExportRequest {
        KeyExportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &KeyExportRequest| { &m.kid },
                    |m: &mut KeyExportRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &KeyExportRequest| { &m.password },
                    |m: &mut KeyExportRequest| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExportType>>(
                    "type",
                    |m: &KeyExportRequest| { &m.field_type },
                    |m: &mut KeyExportRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyExportRequest>(
                    "KeyExportRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyExportRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeyExportRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyExportRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeyExportRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.password.clear();
        self.field_type = ExportType::DEFAULT_EXPORT_TYPE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyExportResponse {
    // message fields
    pub export: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyExportResponse {
    fn default() -> &'a KeyExportResponse {
        <KeyExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyExportResponse {
    pub fn new() -> KeyExportResponse {
        ::std::default::Default::default()
    }

    // bytes export = 1;


    pub fn get_export(&self) -> &[u8] {
        &self.export
    }
    pub fn clear_export(&mut self) {
        self.export.clear();
    }

    // Param is passed by value, moved
    pub fn set_export(&mut self, v: ::std::vec::Vec<u8>) {
        self.export = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_export(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.export
    }

    // Take field
    pub fn take_export(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.export, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeyExportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.export)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.export.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.export);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.export.is_empty() {
            os.write_bytes(1, &self.export)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyExportResponse {
        KeyExportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "export",
                    |m: &KeyExportResponse| { &m.export },
                    |m: &mut KeyExportResponse| { &mut m.export },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyExportResponse>(
                    "KeyExportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyExportResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeyExportResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyExportResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeyExportResponse {
    fn clear(&mut self) {
        self.export.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyImportRequest {
    // message fields
    pub field_in: ::std::vec::Vec<u8>,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyImportRequest {
    fn default() -> &'a KeyImportRequest {
        <KeyImportRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyImportRequest {
    pub fn new() -> KeyImportRequest {
        ::std::default::Default::default()
    }

    // bytes in = 1;


    pub fn get_field_in(&self) -> &[u8] {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_in, ::std::vec::Vec::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyImportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.field_in);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_bytes(1, &self.field_in)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyImportRequest {
        KeyImportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "in",
                    |m: &KeyImportRequest| { &m.field_in },
                    |m: &mut KeyImportRequest| { &mut m.field_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &KeyImportRequest| { &m.password },
                    |m: &mut KeyImportRequest| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyImportRequest>(
                    "KeyImportRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyImportRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeyImportRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyImportRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeyImportRequest {
    fn clear(&mut self) {
        self.field_in.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyImportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyImportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyImportResponse {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyImportResponse {
    fn default() -> &'a KeyImportResponse {
        <KeyImportResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyImportResponse {
    pub fn new() -> KeyImportResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyImportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyImportResponse {
        KeyImportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &KeyImportResponse| { &m.kid },
                    |m: &mut KeyImportResponse| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyImportResponse>(
                    "KeyImportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyImportResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeyImportResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyImportResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeyImportResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyImportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyImportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRemoveRequest {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRemoveRequest {
    fn default() -> &'a KeyRemoveRequest {
        <KeyRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyRemoveRequest {
    pub fn new() -> KeyRemoveRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRemoveRequest {
        KeyRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &KeyRemoveRequest| { &m.kid },
                    |m: &mut KeyRemoveRequest| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRemoveRequest>(
                    "KeyRemoveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyRemoveRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeyRemoveRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyRemoveRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeyRemoveRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRemoveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRemoveResponse {
    fn default() -> &'a KeyRemoveResponse {
        <KeyRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyRemoveResponse {
    pub fn new() -> KeyRemoveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KeyRemoveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRemoveResponse {
        KeyRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRemoveResponse>(
                    "KeyRemoveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyRemoveResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeyRemoveResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyRemoveResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeyRemoveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message fields
    pub id: ::std::string::String,
    pub field_type: KeyType,
    pub user: ::protobuf::SingularPtrField<User>,
    pub saved: bool,
    pub sigchainLength: i32,
    pub sigchainUpdatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .service.KeyType type = 3;


    pub fn get_field_type(&self) -> KeyType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = KeyType::UNKNOWN_KEY_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: KeyType) {
        self.field_type = v;
    }

    // .service.User user = 6;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // bool saved = 10;


    pub fn get_saved(&self) -> bool {
        self.saved
    }
    pub fn clear_saved(&mut self) {
        self.saved = false;
    }

    // Param is passed by value, moved
    pub fn set_saved(&mut self, v: bool) {
        self.saved = v;
    }

    // int32 sigchainLength = 40;


    pub fn get_sigchainLength(&self) -> i32 {
        self.sigchainLength
    }
    pub fn clear_sigchainLength(&mut self) {
        self.sigchainLength = 0;
    }

    // Param is passed by value, moved
    pub fn set_sigchainLength(&mut self, v: i32) {
        self.sigchainLength = v;
    }

    // int64 sigchainUpdatedAt = 41;


    pub fn get_sigchainUpdatedAt(&self) -> i64 {
        self.sigchainUpdatedAt
    }
    pub fn clear_sigchainUpdatedAt(&mut self) {
        self.sigchainUpdatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_sigchainUpdatedAt(&mut self, v: i64) {
        self.sigchainUpdatedAt = v;
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.saved = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sigchainLength = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sigchainUpdatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.field_type != KeyType::UNKNOWN_KEY_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.saved != false {
            my_size += 2;
        }
        if self.sigchainLength != 0 {
            my_size += ::protobuf::rt::value_size(40, self.sigchainLength, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sigchainUpdatedAt != 0 {
            my_size += ::protobuf::rt::value_size(41, self.sigchainUpdatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.field_type != KeyType::UNKNOWN_KEY_TYPE {
            os.write_enum(3, self.field_type.value())?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.saved != false {
            os.write_bool(10, self.saved)?;
        }
        if self.sigchainLength != 0 {
            os.write_int32(40, self.sigchainLength)?;
        }
        if self.sigchainUpdatedAt != 0 {
            os.write_int64(41, self.sigchainUpdatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Key| { &m.id },
                    |m: &mut Key| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyType>>(
                    "type",
                    |m: &Key| { &m.field_type },
                    |m: &mut Key| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &Key| { &m.user },
                    |m: &mut Key| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "saved",
                    |m: &Key| { &m.saved },
                    |m: &mut Key| { &mut m.saved },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sigchainLength",
                    |m: &Key| { &m.sigchainLength },
                    |m: &mut Key| { &mut m.sigchainLength },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sigchainUpdatedAt",
                    |m: &Key| { &m.sigchainUpdatedAt },
                    |m: &mut Key| { &mut m.sigchainUpdatedAt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key>(
                    "Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key {
        static mut instance: ::protobuf::lazy::Lazy<Key> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Key::new)
        }
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = KeyType::UNKNOWN_KEY_TYPE;
        self.user.clear();
        self.saved = false;
        self.sigchainLength = 0;
        self.sigchainUpdatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRequest {
    // message fields
    pub identity: ::std::string::String,
    pub update: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRequest {
    fn default() -> &'a KeyRequest {
        <KeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyRequest {
    pub fn new() -> KeyRequest {
        ::std::default::Default::default()
    }

    // string identity = 1;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }

    // bool update = 5;


    pub fn get_update(&self) -> bool {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = false;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = v;
    }
}

impl ::protobuf::Message for KeyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity);
        }
        if self.update != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity.is_empty() {
            os.write_string(1, &self.identity)?;
        }
        if self.update != false {
            os.write_bool(5, self.update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRequest {
        KeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity",
                    |m: &KeyRequest| { &m.identity },
                    |m: &mut KeyRequest| { &mut m.identity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "update",
                    |m: &KeyRequest| { &m.update },
                    |m: &mut KeyRequest| { &mut m.update },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRequest>(
                    "KeyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeyRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeyRequest {
    fn clear(&mut self) {
        self.identity.clear();
        self.update = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyResponse {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyResponse {
    fn default() -> &'a KeyResponse {
        <KeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyResponse {
    pub fn new() -> KeyResponse {
        ::std::default::Default::default()
    }

    // .service.Key key = 1;


    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for KeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyResponse {
        KeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "key",
                    |m: &KeyResponse| { &m.key },
                    |m: &mut KeyResponse| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyResponse>(
                    "KeyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeyResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeyResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeysRequest {
    // message fields
    pub query: ::std::string::String,
    pub types: ::std::vec::Vec<KeyType>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeysRequest {
    fn default() -> &'a KeysRequest {
        <KeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeysRequest {
    pub fn new() -> KeysRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // repeated .service.KeyType types = 2;


    pub fn get_types(&self) -> &[KeyType] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<KeyType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<KeyType> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<KeyType> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for KeysRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 2, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        for v in &self.types {
            os.write_enum(2, v.value())?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, self.sortDirection.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeysRequest {
        KeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &KeysRequest| { &m.query },
                    |m: &mut KeysRequest| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<KeyType>>(
                    "types",
                    |m: &KeysRequest| { &m.types },
                    |m: &mut KeysRequest| { &mut m.types },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sortField",
                    |m: &KeysRequest| { &m.sortField },
                    |m: &mut KeysRequest| { &mut m.sortField },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                    "sortDirection",
                    |m: &KeysRequest| { &m.sortDirection },
                    |m: &mut KeysRequest| { &mut m.sortDirection },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeysRequest>(
                    "KeysRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeysRequest {
        static mut instance: ::protobuf::lazy::Lazy<KeysRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeysRequest::new)
        }
    }
}

impl ::protobuf::Clear for KeysRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.types.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeysResponse {
    // message fields
    pub keys: ::protobuf::RepeatedField<Key>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeysResponse {
    fn default() -> &'a KeysResponse {
        <KeysResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeysResponse {
    pub fn new() -> KeysResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Key keys = 1;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for KeysResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, self.sortDirection.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeysResponse {
        KeysResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "keys",
                    |m: &KeysResponse| { &m.keys },
                    |m: &mut KeysResponse| { &mut m.keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sortField",
                    |m: &KeysResponse| { &m.sortField },
                    |m: &mut KeysResponse| { &mut m.sortField },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                    "sortDirection",
                    |m: &KeysResponse| { &m.sortDirection },
                    |m: &mut KeysResponse| { &mut m.sortDirection },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeysResponse>(
                    "KeysResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeysResponse {
        static mut instance: ::protobuf::lazy::Lazy<KeysResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeysResponse::new)
        }
    }
}

impl ::protobuf::Clear for KeysResponse {
    fn clear(&mut self) {
        self.keys.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeysResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeysResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub field_type: SecretType,
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub url: ::std::string::String,
    pub notes: ::std::string::String,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Secret {
    fn default() -> &'a Secret {
        <Secret as ::protobuf::Message>::default_instance()
    }
}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .service.SecretType type = 3;


    pub fn get_field_type(&self) -> SecretType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SecretType::UNKNOWN_SECRET_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SecretType) {
        self.field_type = v;
    }

    // string username = 10;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 11;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string url = 20;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string notes = 30;


    pub fn get_notes(&self) -> &str {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notes, ::std::string::String::new())
    }

    // int64 createdAt = 100;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 101;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for Secret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notes)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.field_type != SecretType::UNKNOWN_SECRET_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.password);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.url);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.notes);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(100, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(101, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.field_type != SecretType::UNKNOWN_SECRET_TYPE {
            os.write_enum(3, self.field_type.value())?;
        }
        if !self.username.is_empty() {
            os.write_string(10, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(11, &self.password)?;
        }
        if !self.url.is_empty() {
            os.write_string(20, &self.url)?;
        }
        if !self.notes.is_empty() {
            os.write_string(30, &self.notes)?;
        }
        if self.createdAt != 0 {
            os.write_int64(100, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(101, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Secret {
        Secret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Secret| { &m.id },
                    |m: &mut Secret| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Secret| { &m.name },
                    |m: &mut Secret| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SecretType>>(
                    "type",
                    |m: &Secret| { &m.field_type },
                    |m: &mut Secret| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &Secret| { &m.username },
                    |m: &mut Secret| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &Secret| { &m.password },
                    |m: &mut Secret| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &Secret| { &m.url },
                    |m: &mut Secret| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "notes",
                    |m: &Secret| { &m.notes },
                    |m: &mut Secret| { &mut m.notes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "createdAt",
                    |m: &Secret| { &m.createdAt },
                    |m: &mut Secret| { &mut m.createdAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "updatedAt",
                    |m: &Secret| { &m.updatedAt },
                    |m: &mut Secret| { &mut m.updatedAt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Secret>(
                    "Secret",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Secret {
        static mut instance: ::protobuf::lazy::Lazy<Secret> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Secret::new)
        }
    }
}

impl ::protobuf::Clear for Secret {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.field_type = SecretType::UNKNOWN_SECRET_TYPE;
        self.username.clear();
        self.password.clear();
        self.url.clear();
        self.notes.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRequest {
    fn default() -> &'a SecretRequest {
        <SecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretRequest {
    pub fn new() -> SecretRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecretRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRequest {
        SecretRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &SecretRequest| { &m.id },
                    |m: &mut SecretRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRequest>(
                    "SecretRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretRequest {
        static mut instance: ::protobuf::lazy::Lazy<SecretRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretRequest::new)
        }
    }
}

impl ::protobuf::Clear for SecretRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretResponse {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretResponse {
    fn default() -> &'a SecretResponse {
        <SecretResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretResponse {
    pub fn new() -> SecretResponse {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| Secret::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretResponse {
        SecretResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secret",
                    |m: &SecretResponse| { &m.secret },
                    |m: &mut SecretResponse| { &mut m.secret },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretResponse>(
                    "SecretResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretResponse {
        static mut instance: ::protobuf::lazy::Lazy<SecretResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretResponse::new)
        }
    }
}

impl ::protobuf::Clear for SecretResponse {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretSaveRequest {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretSaveRequest {
    fn default() -> &'a SecretSaveRequest {
        <SecretSaveRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretSaveRequest {
    pub fn new() -> SecretSaveRequest {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| Secret::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretSaveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretSaveRequest {
        SecretSaveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secret",
                    |m: &SecretSaveRequest| { &m.secret },
                    |m: &mut SecretSaveRequest| { &mut m.secret },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretSaveRequest>(
                    "SecretSaveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretSaveRequest {
        static mut instance: ::protobuf::lazy::Lazy<SecretSaveRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretSaveRequest::new)
        }
    }
}

impl ::protobuf::Clear for SecretSaveRequest {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretSaveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretSaveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretSaveResponse {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretSaveResponse {
    fn default() -> &'a SecretSaveResponse {
        <SecretSaveResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretSaveResponse {
    pub fn new() -> SecretSaveResponse {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| Secret::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretSaveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretSaveResponse {
        SecretSaveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secret",
                    |m: &SecretSaveResponse| { &m.secret },
                    |m: &mut SecretSaveResponse| { &mut m.secret },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretSaveResponse>(
                    "SecretSaveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretSaveResponse {
        static mut instance: ::protobuf::lazy::Lazy<SecretSaveResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretSaveResponse::new)
        }
    }
}

impl ::protobuf::Clear for SecretSaveResponse {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretSaveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretSaveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRemoveRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRemoveRequest {
    fn default() -> &'a SecretRemoveRequest {
        <SecretRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretRemoveRequest {
    pub fn new() -> SecretRemoveRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecretRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRemoveRequest {
        SecretRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &SecretRemoveRequest| { &m.id },
                    |m: &mut SecretRemoveRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRemoveRequest>(
                    "SecretRemoveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretRemoveRequest {
        static mut instance: ::protobuf::lazy::Lazy<SecretRemoveRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretRemoveRequest::new)
        }
    }
}

impl ::protobuf::Clear for SecretRemoveRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRemoveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRemoveResponse {
    fn default() -> &'a SecretRemoveResponse {
        <SecretRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretRemoveResponse {
    pub fn new() -> SecretRemoveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SecretRemoveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRemoveResponse {
        SecretRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRemoveResponse>(
                    "SecretRemoveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretRemoveResponse {
        static mut instance: ::protobuf::lazy::Lazy<SecretRemoveResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretRemoveResponse::new)
        }
    }
}

impl ::protobuf::Clear for SecretRemoveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsRequest {
    // message fields
    pub query: ::std::string::String,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsRequest {
    fn default() -> &'a SecretsRequest {
        <SecretsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretsRequest {
    pub fn new() -> SecretsRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for SecretsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, self.sortDirection.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsRequest {
        SecretsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SecretsRequest| { &m.query },
                    |m: &mut SecretsRequest| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sortField",
                    |m: &SecretsRequest| { &m.sortField },
                    |m: &mut SecretsRequest| { &mut m.sortField },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                    "sortDirection",
                    |m: &SecretsRequest| { &m.sortDirection },
                    |m: &mut SecretsRequest| { &mut m.sortDirection },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsRequest>(
                    "SecretsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SecretsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SecretsRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsResponse {
    // message fields
    pub secrets: ::protobuf::RepeatedField<Secret>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsResponse {
    fn default() -> &'a SecretsResponse {
        <SecretsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretsResponse {
    pub fn new() -> SecretsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Secret secrets = 1;


    pub fn get_secrets(&self) -> &[Secret] {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<Secret>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<Secret> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<Secret> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for SecretsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.secrets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, self.sortDirection.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsResponse {
        SecretsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "secrets",
                    |m: &SecretsResponse| { &m.secrets },
                    |m: &mut SecretsResponse| { &mut m.secrets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sortField",
                    |m: &SecretsResponse| { &m.sortField },
                    |m: &mut SecretsResponse| { &mut m.sortField },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                    "sortDirection",
                    |m: &SecretsResponse| { &m.sortDirection },
                    |m: &mut SecretsResponse| { &mut m.sortDirection },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsResponse>(
                    "SecretsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretsResponse {
        static mut instance: ::protobuf::lazy::Lazy<SecretsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SecretsResponse::new)
        }
    }
}

impl ::protobuf::Clear for SecretsResponse {
    fn clear(&mut self) {
        self.secrets.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemRequest {
    fn default() -> &'a ItemRequest {
        <ItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl ItemRequest {
    pub fn new() -> ItemRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ItemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemRequest {
        ItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ItemRequest| { &m.id },
                    |m: &mut ItemRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemRequest>(
                    "ItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<ItemRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ItemRequest::new)
        }
    }
}

impl ::protobuf::Clear for ItemRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemResponse {
    // message fields
    pub item: ::protobuf::SingularPtrField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemResponse {
    fn default() -> &'a ItemResponse {
        <ItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl ItemResponse {
    pub fn new() -> ItemResponse {
        ::std::default::Default::default()
    }

    // .service.Item item = 1;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| Item::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }
}

impl ::protobuf::Message for ItemResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemResponse {
        ItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                    "item",
                    |m: &ItemResponse| { &m.item },
                    |m: &mut ItemResponse| { &mut m.item },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemResponse>(
                    "ItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<ItemResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for ItemResponse {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemsRequest {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemsRequest {
    fn default() -> &'a ItemsRequest {
        <ItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ItemsRequest {
    pub fn new() -> ItemsRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ItemsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemsRequest {
        ItemsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &ItemsRequest| { &m.query },
                    |m: &mut ItemsRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemsRequest>(
                    "ItemsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ItemsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ItemsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ItemsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ItemsRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ItemsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ItemsResponse {
    fn default() -> &'a ItemsResponse {
        <ItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ItemsResponse {
    pub fn new() -> ItemsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Item items = 1;


    pub fn get_items(&self) -> &[Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ItemsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ItemsResponse {
        ItemsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Item>>(
                    "items",
                    |m: &ItemsResponse| { &m.items },
                    |m: &mut ItemsResponse| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ItemsResponse>(
                    "ItemsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ItemsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ItemsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ItemsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ItemsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ItemsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Item {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Item {
        Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Item| { &m.id },
                    |m: &mut Item| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Item| { &m.field_type },
                    |m: &mut Item| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Item>(
                    "Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Item {
        static mut instance: ::protobuf::lazy::Lazy<Item> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Item::new)
        }
    }
}

impl ::protobuf::Clear for Item {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandRequest {
    // message fields
    pub numBytes: i32,
    pub encoding: Encoding,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandRequest {
    fn default() -> &'a RandRequest {
        <RandRequest as ::protobuf::Message>::default_instance()
    }
}

impl RandRequest {
    pub fn new() -> RandRequest {
        ::std::default::Default::default()
    }

    // int32 numBytes = 1;


    pub fn get_numBytes(&self) -> i32 {
        self.numBytes
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: i32) {
        self.numBytes = v;
    }

    // .service.Encoding encoding = 2;


    pub fn get_encoding(&self) -> Encoding {
        self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding = Encoding::HEX;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: Encoding) {
        self.encoding = v;
    }
}

impl ::protobuf::Message for RandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numBytes = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.numBytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.numBytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.encoding != Encoding::HEX {
            my_size += ::protobuf::rt::enum_size(2, self.encoding);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.numBytes != 0 {
            os.write_int32(1, self.numBytes)?;
        }
        if self.encoding != Encoding::HEX {
            os.write_enum(2, self.encoding.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandRequest {
        RandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "numBytes",
                    |m: &RandRequest| { &m.numBytes },
                    |m: &mut RandRequest| { &mut m.numBytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Encoding>>(
                    "encoding",
                    |m: &RandRequest| { &m.encoding },
                    |m: &mut RandRequest| { &mut m.encoding },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandRequest>(
                    "RandRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RandRequest {
        static mut instance: ::protobuf::lazy::Lazy<RandRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RandRequest::new)
        }
    }
}

impl ::protobuf::Clear for RandRequest {
    fn clear(&mut self) {
        self.numBytes = 0;
        self.encoding = Encoding::HEX;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandResponse {
    // message fields
    pub data: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandResponse {
    fn default() -> &'a RandResponse {
        <RandResponse as ::protobuf::Message>::default_instance()
    }
}

impl RandResponse {
    pub fn new() -> RandResponse {
        ::std::default::Default::default()
    }

    // string data = 1;


    pub fn get_data(&self) -> &str {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RandResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_string(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandResponse {
        RandResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    |m: &RandResponse| { &m.data },
                    |m: &mut RandResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandResponse>(
                    "RandResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RandResponse {
        static mut instance: ::protobuf::lazy::Lazy<RandResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RandResponse::new)
        }
    }
}

impl ::protobuf::Clear for RandResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandPasswordRequest {
    // message fields
    pub length: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandPasswordRequest {
    fn default() -> &'a RandPasswordRequest {
        <RandPasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl RandPasswordRequest {
    pub fn new() -> RandPasswordRequest {
        ::std::default::Default::default()
    }

    // int32 length = 1;


    pub fn get_length(&self) -> i32 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = v;
    }
}

impl ::protobuf::Message for RandPasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(1, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.length != 0 {
            os.write_int32(1, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandPasswordRequest {
        RandPasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "length",
                    |m: &RandPasswordRequest| { &m.length },
                    |m: &mut RandPasswordRequest| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandPasswordRequest>(
                    "RandPasswordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RandPasswordRequest {
        static mut instance: ::protobuf::lazy::Lazy<RandPasswordRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RandPasswordRequest::new)
        }
    }
}

impl ::protobuf::Clear for RandPasswordRequest {
    fn clear(&mut self) {
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandPasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandPasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandPasswordResponse {
    // message fields
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandPasswordResponse {
    fn default() -> &'a RandPasswordResponse {
        <RandPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl RandPasswordResponse {
    pub fn new() -> RandPasswordResponse {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RandPasswordResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandPasswordResponse {
        RandPasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &RandPasswordResponse| { &m.password },
                    |m: &mut RandPasswordResponse| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandPasswordResponse>(
                    "RandPasswordResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RandPasswordResponse {
        static mut instance: ::protobuf::lazy::Lazy<RandPasswordResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RandPasswordResponse::new)
        }
    }
}

impl ::protobuf::Clear for RandPasswordResponse {
    fn clear(&mut self) {
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandPasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullRequest {
    // message fields
    pub identity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    // string identity = 1;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity.is_empty() {
            os.write_string(1, &self.identity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity",
                    |m: &PullRequest| { &m.identity },
                    |m: &mut PullRequest| { &mut m.identity },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullRequest>(
                    "PullRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PullRequest {
        static mut instance: ::protobuf::lazy::Lazy<PullRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PullRequest::new)
        }
    }
}

impl ::protobuf::Clear for PullRequest {
    fn clear(&mut self) {
        self.identity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullResponse {
    // message fields
    pub kids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    // repeated string kids = 1;


    pub fn get_kids(&self) -> &[::std::string::String] {
        &self.kids
    }
    pub fn clear_kids(&mut self) {
        self.kids.clear();
    }

    // Param is passed by value, moved
    pub fn set_kids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.kids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.kids
    }

    // Take field
    pub fn take_kids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.kids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PullResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.kids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kids",
                    |m: &PullResponse| { &m.kids },
                    |m: &mut PullResponse| { &mut m.kids },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullResponse>(
                    "PullResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PullResponse {
        static mut instance: ::protobuf::lazy::Lazy<PullResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PullResponse::new)
        }
    }
}

impl ::protobuf::Clear for PullResponse {
    fn clear(&mut self) {
        self.kids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushRequest {
    // message fields
    pub identity: ::std::string::String,
    pub remoteCheck: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushRequest {
    fn default() -> &'a PushRequest {
        <PushRequest as ::protobuf::Message>::default_instance()
    }
}

impl PushRequest {
    pub fn new() -> PushRequest {
        ::std::default::Default::default()
    }

    // string identity = 1;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }

    // bool remoteCheck = 2;


    pub fn get_remoteCheck(&self) -> bool {
        self.remoteCheck
    }
    pub fn clear_remoteCheck(&mut self) {
        self.remoteCheck = false;
    }

    // Param is passed by value, moved
    pub fn set_remoteCheck(&mut self, v: bool) {
        self.remoteCheck = v;
    }
}

impl ::protobuf::Message for PushRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remoteCheck = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity);
        }
        if self.remoteCheck != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity.is_empty() {
            os.write_string(1, &self.identity)?;
        }
        if self.remoteCheck != false {
            os.write_bool(2, self.remoteCheck)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushRequest {
        PushRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity",
                    |m: &PushRequest| { &m.identity },
                    |m: &mut PushRequest| { &mut m.identity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remoteCheck",
                    |m: &PushRequest| { &m.remoteCheck },
                    |m: &mut PushRequest| { &mut m.remoteCheck },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushRequest>(
                    "PushRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PushRequest {
        static mut instance: ::protobuf::lazy::Lazy<PushRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PushRequest::new)
        }
    }
}

impl ::protobuf::Clear for PushRequest {
    fn clear(&mut self) {
        self.identity.clear();
        self.remoteCheck = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushResponse {
    // message fields
    pub kid: ::std::string::String,
    pub urls: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushResponse {
    fn default() -> &'a PushResponse {
        <PushResponse as ::protobuf::Message>::default_instance()
    }
}

impl PushResponse {
    pub fn new() -> PushResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // repeated string urls = 2;


    pub fn get_urls(&self) -> &[::std::string::String] {
        &self.urls
    }
    pub fn clear_urls(&mut self) {
        self.urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_urls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_urls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.urls
    }

    // Take field
    pub fn take_urls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.urls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PushResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.urls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        for value in &self.urls {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        for v in &self.urls {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushResponse {
        PushResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &PushResponse| { &m.kid },
                    |m: &mut PushResponse| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "urls",
                    |m: &PushResponse| { &m.urls },
                    |m: &mut PushResponse| { &mut m.urls },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushResponse>(
                    "PushResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PushResponse {
        static mut instance: ::protobuf::lazy::Lazy<PushResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PushResponse::new)
        }
    }
}

impl ::protobuf::Clear for PushResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.urls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Collection {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Collection {
    fn default() -> &'a Collection {
        <Collection as ::protobuf::Message>::default_instance()
    }
}

impl Collection {
    pub fn new() -> Collection {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Collection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Collection {
        Collection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &Collection| { &m.path },
                    |m: &mut Collection| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Collection>(
                    "Collection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Collection {
        static mut instance: ::protobuf::lazy::Lazy<Collection> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Collection::new)
        }
    }
}

impl ::protobuf::Clear for Collection {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Collection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectionsRequest {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectionsRequest {
    fn default() -> &'a CollectionsRequest {
        <CollectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CollectionsRequest {
    pub fn new() -> CollectionsRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CollectionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectionsRequest {
        CollectionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CollectionsRequest| { &m.path },
                    |m: &mut CollectionsRequest| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectionsRequest>(
                    "CollectionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CollectionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CollectionsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CollectionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for CollectionsRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectionsResponse {
    // message fields
    pub collections: ::protobuf::RepeatedField<Collection>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectionsResponse {
    fn default() -> &'a CollectionsResponse {
        <CollectionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CollectionsResponse {
    pub fn new() -> CollectionsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Collection collections = 1;


    pub fn get_collections(&self) -> &[Collection] {
        &self.collections
    }
    pub fn clear_collections(&mut self) {
        self.collections.clear();
    }

    // Param is passed by value, moved
    pub fn set_collections(&mut self, v: ::protobuf::RepeatedField<Collection>) {
        self.collections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collections(&mut self) -> &mut ::protobuf::RepeatedField<Collection> {
        &mut self.collections
    }

    // Take field
    pub fn take_collections(&mut self) -> ::protobuf::RepeatedField<Collection> {
        ::std::mem::replace(&mut self.collections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CollectionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.collections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.collections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.collections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectionsResponse {
        CollectionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Collection>>(
                    "collections",
                    |m: &CollectionsResponse| { &m.collections },
                    |m: &mut CollectionsResponse| { &mut m.collections },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectionsResponse>(
                    "CollectionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CollectionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CollectionsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CollectionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for CollectionsResponse {
    fn clear(&mut self) {
        self.collections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub path: ::std::string::String,
    pub value: ::std::string::String,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Document {
    fn default() -> &'a Document {
        <Document as ::protobuf::Message>::default_instance()
    }
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // int64 createdAt = 10;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 11;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(10, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(11, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.createdAt != 0 {
            os.write_int64(10, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(11, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &Document| { &m.path },
                    |m: &mut Document| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Document| { &m.value },
                    |m: &mut Document| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "createdAt",
                    |m: &Document| { &m.createdAt },
                    |m: &mut Document| { &mut m.createdAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "updatedAt",
                    |m: &Document| { &m.updatedAt },
                    |m: &mut Document| { &mut m.updatedAt },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Document>(
                    "Document",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Document {
        static mut instance: ::protobuf::lazy::Lazy<Document> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Document::new)
        }
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.path.clear();
        self.value.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentsRequest {
    // message fields
    pub path: ::std::string::String,
    pub prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentsRequest {
    fn default() -> &'a DocumentsRequest {
        <DocumentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DocumentsRequest {
    pub fn new() -> DocumentsRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string prefix = 2;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DocumentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(2, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentsRequest {
        DocumentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &DocumentsRequest| { &m.path },
                    |m: &mut DocumentsRequest| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &DocumentsRequest| { &m.prefix },
                    |m: &mut DocumentsRequest| { &mut m.prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentsRequest>(
                    "DocumentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DocumentsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DocumentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DocumentsRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentsResponse {
    // message fields
    pub documents: ::protobuf::RepeatedField<Document>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentsResponse {
    fn default() -> &'a DocumentsResponse {
        <DocumentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DocumentsResponse {
    pub fn new() -> DocumentsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Document documents = 1;


    pub fn get_documents(&self) -> &[Document] {
        &self.documents
    }
    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<Document>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<Document> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<Document> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DocumentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.documents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentsResponse {
        DocumentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "documents",
                    |m: &DocumentsResponse| { &m.documents },
                    |m: &mut DocumentsResponse| { &mut m.documents },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentsResponse>(
                    "DocumentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DocumentsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DocumentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DocumentsResponse {
    fn clear(&mut self) {
        self.documents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentDeleteRequest {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDeleteRequest {
    fn default() -> &'a DocumentDeleteRequest {
        <DocumentDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDeleteRequest {
    pub fn new() -> DocumentDeleteRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DocumentDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDeleteRequest {
        DocumentDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &DocumentDeleteRequest| { &m.path },
                    |m: &mut DocumentDeleteRequest| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDeleteRequest>(
                    "DocumentDeleteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentDeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<DocumentDeleteRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DocumentDeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for DocumentDeleteRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentDeleteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDeleteResponse {
    fn default() -> &'a DocumentDeleteResponse {
        <DocumentDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDeleteResponse {
    pub fn new() -> DocumentDeleteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DocumentDeleteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDeleteResponse {
        DocumentDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDeleteResponse>(
                    "DocumentDeleteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentDeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<DocumentDeleteResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DocumentDeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for DocumentDeleteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub kid: ::std::string::String,
    pub seq: i32,
    pub service: ::std::string::String,
    pub url: ::std::string::String,
    pub status: UserStatus,
    pub verifiedAt: i64,
    pub timestamp: i64,
    pub err: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string kid = 3;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 4;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // string service = 5;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string url = 6;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // .service.UserStatus status = 10;


    pub fn get_status(&self) -> UserStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = UserStatus::USER_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UserStatus) {
        self.status = v;
    }

    // int64 verifiedAt = 11;


    pub fn get_verifiedAt(&self) -> i64 {
        self.verifiedAt
    }
    pub fn clear_verifiedAt(&mut self) {
        self.verifiedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_verifiedAt(&mut self, v: i64) {
        self.verifiedAt = v;
    }

    // int64 timestamp = 12;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string err = 20;


    pub fn get_err(&self) -> &str {
        &self.err
    }
    pub fn clear_err(&mut self) {
        self.err.clear();
    }

    // Param is passed by value, moved
    pub fn set_err(&mut self, v: ::std::string::String) {
        self.err = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_err(&mut self) -> &mut ::std::string::String {
        &mut self.err
    }

    // Take field
    pub fn take_err(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.err, ::std::string::String::new())
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.verifiedAt = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.err)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.service);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.url);
        }
        if self.status != UserStatus::USER_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.status);
        }
        if self.verifiedAt != 0 {
            my_size += ::protobuf::rt::value_size(11, self.verifiedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(12, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.err.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.err);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.kid.is_empty() {
            os.write_string(3, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(4, self.seq)?;
        }
        if !self.service.is_empty() {
            os.write_string(5, &self.service)?;
        }
        if !self.url.is_empty() {
            os.write_string(6, &self.url)?;
        }
        if self.status != UserStatus::USER_UNKNOWN {
            os.write_enum(10, self.status.value())?;
        }
        if self.verifiedAt != 0 {
            os.write_int64(11, self.verifiedAt)?;
        }
        if self.timestamp != 0 {
            os.write_int64(12, self.timestamp)?;
        }
        if !self.err.is_empty() {
            os.write_string(20, &self.err)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &User| { &m.id },
                    |m: &mut User| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &User| { &m.name },
                    |m: &mut User| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &User| { &m.kid },
                    |m: &mut User| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seq",
                    |m: &User| { &m.seq },
                    |m: &mut User| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &User| { &m.service },
                    |m: &mut User| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &User| { &m.url },
                    |m: &mut User| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserStatus>>(
                    "status",
                    |m: &User| { &m.status },
                    |m: &mut User| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "verifiedAt",
                    |m: &User| { &m.verifiedAt },
                    |m: &mut User| { &mut m.verifiedAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &User| { &m.timestamp },
                    |m: &mut User| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "err",
                    |m: &User| { &m.err },
                    |m: &mut User| { &mut m.err },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<User>(
                    "User",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static User {
        static mut instance: ::protobuf::lazy::Lazy<User> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(User::new)
        }
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.kid.clear();
        self.seq = 0;
        self.service.clear();
        self.url.clear();
        self.status = UserStatus::USER_UNKNOWN;
        self.verifiedAt = 0;
        self.timestamp = 0;
        self.err.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserRequest {
    // message fields
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserRequest {
    fn default() -> &'a UserRequest {
        <UserRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserRequest {
    pub fn new() -> UserRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserRequest {
        UserRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &UserRequest| { &m.kid },
                    |m: &mut UserRequest| { &mut m.kid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &UserRequest| { &m.local },
                    |m: &mut UserRequest| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserRequest>(
                    "UserRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserRequest {
        static mut instance: ::protobuf::lazy::Lazy<UserRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserRequest::new)
        }
    }
}

impl ::protobuf::Clear for UserRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserResponse {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserResponse {
    fn default() -> &'a UserResponse {
        <UserResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserResponse {
    pub fn new() -> UserResponse {
        ::std::default::Default::default()
    }

    // .service.User user = 1;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }
}

impl ::protobuf::Message for UserResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserResponse {
        UserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &UserResponse| { &m.user },
                    |m: &mut UserResponse| { &mut m.user },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserResponse>(
                    "UserResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserResponse {
        static mut instance: ::protobuf::lazy::Lazy<UserResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserResponse::new)
        }
    }
}

impl ::protobuf::Clear for UserResponse {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSearchRequest {
    // message fields
    pub query: ::std::string::String,
    pub limit: i32,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSearchRequest {
    fn default() -> &'a UserSearchRequest {
        <UserSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserSearchRequest {
    pub fn new() -> UserSearchRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // int32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserSearchRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if self.limit != 0 {
            os.write_int32(3, self.limit)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSearchRequest {
        UserSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &UserSearchRequest| { &m.query },
                    |m: &mut UserSearchRequest| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "limit",
                    |m: &UserSearchRequest| { &m.limit },
                    |m: &mut UserSearchRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local",
                    |m: &UserSearchRequest| { &m.local },
                    |m: &mut UserSearchRequest| { &mut m.local },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSearchRequest>(
                    "UserSearchRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserSearchRequest {
        static mut instance: ::protobuf::lazy::Lazy<UserSearchRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserSearchRequest::new)
        }
    }
}

impl ::protobuf::Clear for UserSearchRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.limit = 0;
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSearchResponse {
    // message fields
    pub users: ::protobuf::RepeatedField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSearchResponse {
    fn default() -> &'a UserSearchResponse {
        <UserSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserSearchResponse {
    pub fn new() -> UserSearchResponse {
        ::std::default::Default::default()
    }

    // repeated .service.User users = 1;


    pub fn get_users(&self) -> &[User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UserSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSearchResponse {
        UserSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "users",
                    |m: &UserSearchResponse| { &m.users },
                    |m: &mut UserSearchResponse| { &mut m.users },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSearchResponse>(
                    "UserSearchResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserSearchResponse {
        static mut instance: ::protobuf::lazy::Lazy<UserSearchResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UserSearchResponse::new)
        }
    }
}

impl ::protobuf::Clear for UserSearchResponse {
    fn clear(&mut self) {
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchRequest {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchRequest {
    fn default() -> &'a SearchRequest {
        <SearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchRequest {
    pub fn new() -> SearchRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchRequest {
        SearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SearchRequest| { &m.query },
                    |m: &mut SearchRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchRequest>(
                    "SearchRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchRequest {
        static mut instance: ::protobuf::lazy::Lazy<SearchRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SearchRequest::new)
        }
    }
}

impl ::protobuf::Clear for SearchRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchResponse {
    // message fields
    pub keys: ::protobuf::RepeatedField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchResponse {
    fn default() -> &'a SearchResponse {
        <SearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchResponse {
    pub fn new() -> SearchResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Key keys = 1;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchResponse {
        SearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "keys",
                    |m: &SearchResponse| { &m.keys },
                    |m: &mut SearchResponse| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchResponse>(
                    "SearchResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchResponse {
        static mut instance: ::protobuf::lazy::Lazy<SearchResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SearchResponse::new)
        }
    }
}

impl ::protobuf::Clear for SearchResponse {
    fn clear(&mut self) {
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchRequest {
    fn default() -> &'a WatchRequest {
        <WatchRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchRequest {
    pub fn new() -> WatchRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WatchRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchRequest {
        WatchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchRequest>(
                    "WatchRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchRequest {
        static mut instance: ::protobuf::lazy::Lazy<WatchRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WatchRequest::new)
        }
    }
}

impl ::protobuf::Clear for WatchRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchEvent {
    // message fields
    pub status: WatchStatus,
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchEvent {
    fn default() -> &'a WatchEvent {
        <WatchEvent as ::protobuf::Message>::default_instance()
    }
}

impl WatchEvent {
    pub fn new() -> WatchEvent {
        ::std::default::Default::default()
    }

    // .service.WatchStatus status = 1;


    pub fn get_status(&self) -> WatchStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = WatchStatus::WATCH_UKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WatchStatus) {
        self.status = v;
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WatchEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != WatchStatus::WATCH_UKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != WatchStatus::WATCH_UKNOWN {
            os.write_enum(1, self.status.value())?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchEvent {
        WatchEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WatchStatus>>(
                    "status",
                    |m: &WatchEvent| { &m.status },
                    |m: &mut WatchEvent| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &WatchEvent| { &m.path },
                    |m: &mut WatchEvent| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchEvent>(
                    "WatchEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchEvent {
        static mut instance: ::protobuf::lazy::Lazy<WatchEvent> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WatchEvent::new)
        }
    }
}

impl ::protobuf::Clear for WatchEvent {
    fn clear(&mut self) {
        self.status = WatchStatus::WATCH_UKNOWN;
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pref {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pref {
    fn default() -> &'a Pref {
        <Pref as ::protobuf::Message>::default_instance()
    }
}

impl Pref {
    pub fn new() -> Pref {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pref {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pref {
        Pref::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &Pref| { &m.key },
                    |m: &mut Pref| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Pref| { &m.value },
                    |m: &mut Pref| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pref>(
                    "Pref",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pref {
        static mut instance: ::protobuf::lazy::Lazy<Pref> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Pref::new)
        }
    }
}

impl ::protobuf::Clear for Pref {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pref {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pref {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferencesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferencesRequest {
    fn default() -> &'a PreferencesRequest {
        <PreferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreferencesRequest {
    pub fn new() -> PreferencesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreferencesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferencesRequest {
        PreferencesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferencesRequest>(
                    "PreferencesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreferencesRequest {
        static mut instance: ::protobuf::lazy::Lazy<PreferencesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreferencesRequest::new)
        }
    }
}

impl ::protobuf::Clear for PreferencesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferencesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferencesResponse {
    // message fields
    pub prefs: ::protobuf::RepeatedField<Pref>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferencesResponse {
    fn default() -> &'a PreferencesResponse {
        <PreferencesResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreferencesResponse {
    pub fn new() -> PreferencesResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Pref prefs = 1;


    pub fn get_prefs(&self) -> &[Pref] {
        &self.prefs
    }
    pub fn clear_prefs(&mut self) {
        self.prefs.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefs(&mut self, v: ::protobuf::RepeatedField<Pref>) {
        self.prefs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefs(&mut self) -> &mut ::protobuf::RepeatedField<Pref> {
        &mut self.prefs
    }

    // Take field
    pub fn take_prefs(&mut self) -> ::protobuf::RepeatedField<Pref> {
        ::std::mem::replace(&mut self.prefs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PreferencesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.prefs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.prefs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.prefs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferencesResponse {
        PreferencesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pref>>(
                    "prefs",
                    |m: &PreferencesResponse| { &m.prefs },
                    |m: &mut PreferencesResponse| { &mut m.prefs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferencesResponse>(
                    "PreferencesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreferencesResponse {
        static mut instance: ::protobuf::lazy::Lazy<PreferencesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreferencesResponse::new)
        }
    }
}

impl ::protobuf::Clear for PreferencesResponse {
    fn clear(&mut self) {
        self.prefs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferencesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferencesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferenceSetRequest {
    // message fields
    pub pref: ::protobuf::SingularPtrField<Pref>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferenceSetRequest {
    fn default() -> &'a PreferenceSetRequest {
        <PreferenceSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreferenceSetRequest {
    pub fn new() -> PreferenceSetRequest {
        ::std::default::Default::default()
    }

    // .service.Pref pref = 1;


    pub fn get_pref(&self) -> &Pref {
        self.pref.as_ref().unwrap_or_else(|| Pref::default_instance())
    }
    pub fn clear_pref(&mut self) {
        self.pref.clear();
    }

    pub fn has_pref(&self) -> bool {
        self.pref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pref(&mut self, v: Pref) {
        self.pref = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pref(&mut self) -> &mut Pref {
        if self.pref.is_none() {
            self.pref.set_default();
        }
        self.pref.as_mut().unwrap()
    }

    // Take field
    pub fn take_pref(&mut self) -> Pref {
        self.pref.take().unwrap_or_else(|| Pref::new())
    }
}

impl ::protobuf::Message for PreferenceSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pref {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pref)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pref.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferenceSetRequest {
        PreferenceSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pref>>(
                    "pref",
                    |m: &PreferenceSetRequest| { &m.pref },
                    |m: &mut PreferenceSetRequest| { &mut m.pref },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferenceSetRequest>(
                    "PreferenceSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreferenceSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<PreferenceSetRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreferenceSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for PreferenceSetRequest {
    fn clear(&mut self) {
        self.pref.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferenceSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferenceSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferenceSetResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferenceSetResponse {
    fn default() -> &'a PreferenceSetResponse {
        <PreferenceSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreferenceSetResponse {
    pub fn new() -> PreferenceSetResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreferenceSetResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferenceSetResponse {
        PreferenceSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferenceSetResponse>(
                    "PreferenceSetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreferenceSetResponse {
        static mut instance: ::protobuf::lazy::Lazy<PreferenceSetResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreferenceSetResponse::new)
        }
    }
}

impl ::protobuf::Clear for PreferenceSetResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferenceSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferenceSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WormholeInput {
    // message fields
    pub sender: ::std::string::String,
    pub recipient: ::std::string::String,
    pub invite: ::std::string::String,
    pub id: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    pub field_type: ContentType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WormholeInput {
    fn default() -> &'a WormholeInput {
        <WormholeInput as ::protobuf::Message>::default_instance()
    }
}

impl WormholeInput {
    pub fn new() -> WormholeInput {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string recipient = 2;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string invite = 3;


    pub fn get_invite(&self) -> &str {
        &self.invite
    }
    pub fn clear_invite(&mut self) {
        self.invite.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite(&mut self, v: ::std::string::String) {
        self.invite = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite(&mut self) -> &mut ::std::string::String {
        &mut self.invite
    }

    // Take field
    pub fn take_invite(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invite, ::std::string::String::new())
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes data = 11;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.ContentType type = 12;


    pub fn get_field_type(&self) -> ContentType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ContentType::BINARY_CONTENT;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ContentType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for WormholeInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invite)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recipient);
        }
        if !self.invite.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.invite);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.data);
        }
        if self.field_type != ContentType::BINARY_CONTENT {
            my_size += ::protobuf::rt::enum_size(12, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(2, &self.recipient)?;
        }
        if !self.invite.is_empty() {
            os.write_string(3, &self.invite)?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(11, &self.data)?;
        }
        if self.field_type != ContentType::BINARY_CONTENT {
            os.write_enum(12, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WormholeInput {
        WormholeInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &WormholeInput| { &m.sender },
                    |m: &mut WormholeInput| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient",
                    |m: &WormholeInput| { &m.recipient },
                    |m: &mut WormholeInput| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite",
                    |m: &WormholeInput| { &m.invite },
                    |m: &mut WormholeInput| { &mut m.invite },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &WormholeInput| { &m.id },
                    |m: &mut WormholeInput| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &WormholeInput| { &m.data },
                    |m: &mut WormholeInput| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                    "type",
                    |m: &WormholeInput| { &m.field_type },
                    |m: &mut WormholeInput| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WormholeInput>(
                    "WormholeInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WormholeInput {
        static mut instance: ::protobuf::lazy::Lazy<WormholeInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WormholeInput::new)
        }
    }
}

impl ::protobuf::Clear for WormholeInput {
    fn clear(&mut self) {
        self.sender.clear();
        self.recipient.clear();
        self.invite.clear();
        self.id.clear();
        self.data.clear();
        self.field_type = ContentType::BINARY_CONTENT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WormholeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WormholeOutput {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    pub status: WormholeStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WormholeOutput {
    fn default() -> &'a WormholeOutput {
        <WormholeOutput as ::protobuf::Message>::default_instance()
    }
}

impl WormholeOutput {
    pub fn new() -> WormholeOutput {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }

    // .service.WormholeStatus status = 2;


    pub fn get_status(&self) -> WormholeStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = WormholeStatus::WORMHOLE_DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WormholeStatus) {
        self.status = v;
    }
}

impl ::protobuf::Message for WormholeOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status != WormholeStatus::WORMHOLE_DEFAULT {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status != WormholeStatus::WORMHOLE_DEFAULT {
            os.write_enum(2, self.status.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WormholeOutput {
        WormholeOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &WormholeOutput| { &m.message },
                    |m: &mut WormholeOutput| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WormholeStatus>>(
                    "status",
                    |m: &WormholeOutput| { &m.status },
                    |m: &mut WormholeOutput| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WormholeOutput>(
                    "WormholeOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WormholeOutput {
        static mut instance: ::protobuf::lazy::Lazy<WormholeOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WormholeOutput::new)
        }
    }
}

impl ::protobuf::Clear for WormholeOutput {
    fn clear(&mut self) {
        self.message.clear();
        self.status = WormholeStatus::WORMHOLE_DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WormholeOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub id: ::std::string::String,
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub recipient: ::protobuf::SingularPtrField<Key>,
    pub field_type: MessageType,
    pub content: ::protobuf::SingularPtrField<Content>,
    pub createdAt: i64,
    pub timeDisplay: ::std::string::String,
    pub dateDisplay: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // .service.Key recipient = 3;


    pub fn get_recipient(&self) -> &Key {
        self.recipient.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    pub fn has_recipient(&self) -> bool {
        self.recipient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: Key) {
        self.recipient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut Key {
        if self.recipient.is_none() {
            self.recipient.set_default();
        }
        self.recipient.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient(&mut self) -> Key {
        self.recipient.take().unwrap_or_else(|| Key::new())
    }

    // .service.MessageType type = 5;


    pub fn get_field_type(&self) -> MessageType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = MessageType::MESSAGE_SENT;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: MessageType) {
        self.field_type = v;
    }

    // .service.Content content = 10;


    pub fn get_content(&self) -> &Content {
        self.content.as_ref().unwrap_or_else(|| Content::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: Content) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut Content {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> Content {
        self.content.take().unwrap_or_else(|| Content::new())
    }

    // int64 createdAt = 21;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // string timeDisplay = 31;


    pub fn get_timeDisplay(&self) -> &str {
        &self.timeDisplay
    }
    pub fn clear_timeDisplay(&mut self) {
        self.timeDisplay.clear();
    }

    // Param is passed by value, moved
    pub fn set_timeDisplay(&mut self, v: ::std::string::String) {
        self.timeDisplay = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeDisplay(&mut self) -> &mut ::std::string::String {
        &mut self.timeDisplay
    }

    // Take field
    pub fn take_timeDisplay(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timeDisplay, ::std::string::String::new())
    }

    // string dateDisplay = 32;


    pub fn get_dateDisplay(&self) -> &str {
        &self.dateDisplay
    }
    pub fn clear_dateDisplay(&mut self) {
        self.dateDisplay.clear();
    }

    // Param is passed by value, moved
    pub fn set_dateDisplay(&mut self, v: ::std::string::String) {
        self.dateDisplay = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dateDisplay(&mut self) -> &mut ::std::string::String {
        &mut self.dateDisplay
    }

    // Take field
    pub fn take_dateDisplay(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dateDisplay, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recipient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recipient)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 5, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                31 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timeDisplay)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dateDisplay)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recipient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != MessageType::MESSAGE_SENT {
            my_size += ::protobuf::rt::enum_size(5, self.field_type);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(21, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.timeDisplay.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.timeDisplay);
        }
        if !self.dateDisplay.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.dateDisplay);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recipient.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != MessageType::MESSAGE_SENT {
            os.write_enum(5, self.field_type.value())?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.createdAt != 0 {
            os.write_int64(21, self.createdAt)?;
        }
        if !self.timeDisplay.is_empty() {
            os.write_string(31, &self.timeDisplay)?;
        }
        if !self.dateDisplay.is_empty() {
            os.write_string(32, &self.dateDisplay)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Message| { &m.id },
                    |m: &mut Message| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "sender",
                    |m: &Message| { &m.sender },
                    |m: &mut Message| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "recipient",
                    |m: &Message| { &m.recipient },
                    |m: &mut Message| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageType>>(
                    "type",
                    |m: &Message| { &m.field_type },
                    |m: &mut Message| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Content>>(
                    "content",
                    |m: &Message| { &m.content },
                    |m: &mut Message| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "createdAt",
                    |m: &Message| { &m.createdAt },
                    |m: &mut Message| { &mut m.createdAt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timeDisplay",
                    |m: &Message| { &m.timeDisplay },
                    |m: &mut Message| { &mut m.timeDisplay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dateDisplay",
                    |m: &Message| { &m.dateDisplay },
                    |m: &mut Message| { &mut m.dateDisplay },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.id.clear();
        self.sender.clear();
        self.recipient.clear();
        self.field_type = MessageType::MESSAGE_SENT;
        self.content.clear();
        self.createdAt = 0;
        self.timeDisplay.clear();
        self.dateDisplay.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Content {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub field_type: ContentType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Content {
    fn default() -> &'a Content {
        <Content as ::protobuf::Message>::default_instance()
    }
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.ContentType type = 2;


    pub fn get_field_type(&self) -> ContentType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ContentType::BINARY_CONTENT;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ContentType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for Content {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.field_type != ContentType::BINARY_CONTENT {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.field_type != ContentType::BINARY_CONTENT {
            os.write_enum(2, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Content {
        Content::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Content| { &m.data },
                    |m: &mut Content| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentType>>(
                    "type",
                    |m: &Content| { &m.field_type },
                    |m: &mut Content| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Content>(
                    "Content",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Content {
        static mut instance: ::protobuf::lazy::Lazy<Content> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Content::new)
        }
    }
}

impl ::protobuf::Clear for Content {
    fn clear(&mut self) {
        self.data.clear();
        self.field_type = ContentType::BINARY_CONTENT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagePrepareRequest {
    // message fields
    pub sender: ::std::string::String,
    pub recipient: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagePrepareRequest {
    fn default() -> &'a MessagePrepareRequest {
        <MessagePrepareRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessagePrepareRequest {
    pub fn new() -> MessagePrepareRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string recipient = 2;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string text = 11;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessagePrepareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recipient);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(2, &self.recipient)?;
        }
        if !self.text.is_empty() {
            os.write_string(11, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagePrepareRequest {
        MessagePrepareRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &MessagePrepareRequest| { &m.sender },
                    |m: &mut MessagePrepareRequest| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient",
                    |m: &MessagePrepareRequest| { &m.recipient },
                    |m: &mut MessagePrepareRequest| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &MessagePrepareRequest| { &m.text },
                    |m: &mut MessagePrepareRequest| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagePrepareRequest>(
                    "MessagePrepareRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessagePrepareRequest {
        static mut instance: ::protobuf::lazy::Lazy<MessagePrepareRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessagePrepareRequest::new)
        }
    }
}

impl ::protobuf::Clear for MessagePrepareRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.recipient.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagePrepareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagePrepareRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagePrepareResponse {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagePrepareResponse {
    fn default() -> &'a MessagePrepareResponse {
        <MessagePrepareResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagePrepareResponse {
    pub fn new() -> MessagePrepareResponse {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for MessagePrepareResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagePrepareResponse {
        MessagePrepareResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &MessagePrepareResponse| { &m.message },
                    |m: &mut MessagePrepareResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagePrepareResponse>(
                    "MessagePrepareResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessagePrepareResponse {
        static mut instance: ::protobuf::lazy::Lazy<MessagePrepareResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessagePrepareResponse::new)
        }
    }
}

impl ::protobuf::Clear for MessagePrepareResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagePrepareResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagePrepareResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageCreateRequest {
    // message fields
    pub sender: ::std::string::String,
    pub recipient: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageCreateRequest {
    fn default() -> &'a MessageCreateRequest {
        <MessageCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageCreateRequest {
    pub fn new() -> MessageCreateRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string recipient = 2;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string text = 11;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recipient);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(2, &self.recipient)?;
        }
        if !self.text.is_empty() {
            os.write_string(11, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageCreateRequest {
        MessageCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &MessageCreateRequest| { &m.sender },
                    |m: &mut MessageCreateRequest| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient",
                    |m: &MessageCreateRequest| { &m.recipient },
                    |m: &mut MessageCreateRequest| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &MessageCreateRequest| { &m.text },
                    |m: &mut MessageCreateRequest| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageCreateRequest>(
                    "MessageCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<MessageCreateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageCreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for MessageCreateRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.recipient.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageCreateResponse {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageCreateResponse {
    fn default() -> &'a MessageCreateResponse {
        <MessageCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessageCreateResponse {
    pub fn new() -> MessageCreateResponse {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for MessageCreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageCreateResponse {
        MessageCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &MessageCreateResponse| { &m.message },
                    |m: &mut MessageCreateResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageCreateResponse>(
                    "MessageCreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageCreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<MessageCreateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageCreateResponse::new)
        }
    }
}

impl ::protobuf::Clear for MessageCreateResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesRequest {
    // message fields
    pub sender: ::std::string::String,
    pub recipient: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesRequest {
    fn default() -> &'a MessagesRequest {
        <MessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessagesRequest {
    pub fn new() -> MessagesRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string recipient = 2;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recipient);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(2, &self.recipient)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesRequest {
        MessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender",
                    |m: &MessagesRequest| { &m.sender },
                    |m: &mut MessagesRequest| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient",
                    |m: &MessagesRequest| { &m.recipient },
                    |m: &mut MessagesRequest| { &mut m.recipient },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesRequest>(
                    "MessagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<MessagesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessagesRequest::new)
        }
    }
}

impl ::protobuf::Clear for MessagesRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.recipient.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesResponse {
    // message fields
    pub messages: ::protobuf::RepeatedField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesResponse {
    fn default() -> &'a MessagesResponse {
        <MessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagesResponse {
    pub fn new() -> MessagesResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Message messages = 1;


    pub fn get_messages(&self) -> &[Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesResponse {
        MessagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "messages",
                    |m: &MessagesResponse| { &m.messages },
                    |m: &mut MessagesResponse| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesResponse>(
                    "MessagesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessagesResponse {
        static mut instance: ::protobuf::lazy::Lazy<MessagesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessagesResponse::new)
        }
    }
}

impl ::protobuf::Clear for MessagesResponse {
    fn clear(&mut self) {
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminSignURLRequest {
    // message fields
    pub signer: ::std::string::String,
    pub method: ::std::string::String,
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminSignURLRequest {
    fn default() -> &'a AdminSignURLRequest {
        <AdminSignURLRequest as ::protobuf::Message>::default_instance()
    }
}

impl AdminSignURLRequest {
    pub fn new() -> AdminSignURLRequest {
        ::std::default::Default::default()
    }

    // string signer = 1;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // string method = 2;


    pub fn get_method(&self) -> &str {
        &self.method
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::std::string::String) {
        self.method = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut ::std::string::String {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method, ::std::string::String::new())
    }

    // string url = 3;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminSignURLRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signer);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.method);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_string(1, &self.signer)?;
        }
        if !self.method.is_empty() {
            os.write_string(2, &self.method)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminSignURLRequest {
        AdminSignURLRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signer",
                    |m: &AdminSignURLRequest| { &m.signer },
                    |m: &mut AdminSignURLRequest| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "method",
                    |m: &AdminSignURLRequest| { &m.method },
                    |m: &mut AdminSignURLRequest| { &mut m.method },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &AdminSignURLRequest| { &m.url },
                    |m: &mut AdminSignURLRequest| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminSignURLRequest>(
                    "AdminSignURLRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdminSignURLRequest {
        static mut instance: ::protobuf::lazy::Lazy<AdminSignURLRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AdminSignURLRequest::new)
        }
    }
}

impl ::protobuf::Clear for AdminSignURLRequest {
    fn clear(&mut self) {
        self.signer.clear();
        self.method.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminSignURLRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminSignURLRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminSignURLResponse {
    // message fields
    pub auth: ::std::string::String,
    pub url: ::std::string::String,
    pub curl: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminSignURLResponse {
    fn default() -> &'a AdminSignURLResponse {
        <AdminSignURLResponse as ::protobuf::Message>::default_instance()
    }
}

impl AdminSignURLResponse {
    pub fn new() -> AdminSignURLResponse {
        ::std::default::Default::default()
    }

    // string auth = 1;


    pub fn get_auth(&self) -> &str {
        &self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: ::std::string::String) {
        self.auth = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut ::std::string::String {
        &mut self.auth
    }

    // Take field
    pub fn take_auth(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string curl = 3;


    pub fn get_curl(&self) -> &str {
        &self.curl
    }
    pub fn clear_curl(&mut self) {
        self.curl.clear();
    }

    // Param is passed by value, moved
    pub fn set_curl(&mut self, v: ::std::string::String) {
        self.curl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_curl(&mut self) -> &mut ::std::string::String {
        &mut self.curl
    }

    // Take field
    pub fn take_curl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.curl, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminSignURLResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.curl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if !self.curl.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.curl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth.is_empty() {
            os.write_string(1, &self.auth)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if !self.curl.is_empty() {
            os.write_string(3, &self.curl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminSignURLResponse {
        AdminSignURLResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth",
                    |m: &AdminSignURLResponse| { &m.auth },
                    |m: &mut AdminSignURLResponse| { &mut m.auth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &AdminSignURLResponse| { &m.url },
                    |m: &mut AdminSignURLResponse| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "curl",
                    |m: &AdminSignURLResponse| { &m.curl },
                    |m: &mut AdminSignURLResponse| { &mut m.curl },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminSignURLResponse>(
                    "AdminSignURLResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdminSignURLResponse {
        static mut instance: ::protobuf::lazy::Lazy<AdminSignURLResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AdminSignURLResponse::new)
        }
    }
}

impl ::protobuf::Clear for AdminSignURLResponse {
    fn clear(&mut self) {
        self.auth.clear();
        self.url.clear();
        self.curl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminSignURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminSignURLResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminCheckRequest {
    // message fields
    pub signer: ::std::string::String,
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminCheckRequest {
    fn default() -> &'a AdminCheckRequest {
        <AdminCheckRequest as ::protobuf::Message>::default_instance()
    }
}

impl AdminCheckRequest {
    pub fn new() -> AdminCheckRequest {
        ::std::default::Default::default()
    }

    // string signer = 1;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminCheckRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signer);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_string(1, &self.signer)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminCheckRequest {
        AdminCheckRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signer",
                    |m: &AdminCheckRequest| { &m.signer },
                    |m: &mut AdminCheckRequest| { &mut m.signer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kid",
                    |m: &AdminCheckRequest| { &m.kid },
                    |m: &mut AdminCheckRequest| { &mut m.kid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminCheckRequest>(
                    "AdminCheckRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdminCheckRequest {
        static mut instance: ::protobuf::lazy::Lazy<AdminCheckRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AdminCheckRequest::new)
        }
    }
}

impl ::protobuf::Clear for AdminCheckRequest {
    fn clear(&mut self) {
        self.signer.clear();
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminCheckRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminCheckRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminCheckResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminCheckResponse {
    fn default() -> &'a AdminCheckResponse {
        <AdminCheckResponse as ::protobuf::Message>::default_instance()
    }
}

impl AdminCheckResponse {
    pub fn new() -> AdminCheckResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AdminCheckResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminCheckResponse {
        AdminCheckResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminCheckResponse>(
                    "AdminCheckResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdminCheckResponse {
        static mut instance: ::protobuf::lazy::Lazy<AdminCheckResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AdminCheckResponse::new)
        }
    }
}

impl ::protobuf::Clear for AdminCheckResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminCheckResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminCheckResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncryptMode {
    DEFAULT_ENCRYPT_MODE = 0,
    ENCRYPT_V2 = 1,
    SIGNCRYPT_V1 = 2,
}

impl ::protobuf::ProtobufEnum for EncryptMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptMode> {
        match value {
            0 => ::std::option::Option::Some(EncryptMode::DEFAULT_ENCRYPT_MODE),
            1 => ::std::option::Option::Some(EncryptMode::ENCRYPT_V2),
            2 => ::std::option::Option::Some(EncryptMode::SIGNCRYPT_V1),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncryptMode] = &[
            EncryptMode::DEFAULT_ENCRYPT_MODE,
            EncryptMode::ENCRYPT_V2,
            EncryptMode::SIGNCRYPT_V1,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<EncryptMode>("EncryptMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncryptMode {
}

impl ::std::default::Default for EncryptMode {
    fn default() -> Self {
        EncryptMode::DEFAULT_ENCRYPT_MODE
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExportType {
    DEFAULT_EXPORT_TYPE = 0,
    SALTPACK_EXPORT_TYPE = 1,
}

impl ::protobuf::ProtobufEnum for ExportType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExportType> {
        match value {
            0 => ::std::option::Option::Some(ExportType::DEFAULT_EXPORT_TYPE),
            1 => ::std::option::Option::Some(ExportType::SALTPACK_EXPORT_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExportType] = &[
            ExportType::DEFAULT_EXPORT_TYPE,
            ExportType::SALTPACK_EXPORT_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExportType>("ExportType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExportType {
}

impl ::std::default::Default for ExportType {
    fn default() -> Self {
        ExportType::DEFAULT_EXPORT_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KeyType {
    UNKNOWN_KEY_TYPE = 0,
    EDX25519 = 10,
    EDX25519_PUBLIC = 11,
    X25519 = 20,
    X25519_PUBLIC = 21,
}

impl ::protobuf::ProtobufEnum for KeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyType> {
        match value {
            0 => ::std::option::Option::Some(KeyType::UNKNOWN_KEY_TYPE),
            10 => ::std::option::Option::Some(KeyType::EDX25519),
            11 => ::std::option::Option::Some(KeyType::EDX25519_PUBLIC),
            20 => ::std::option::Option::Some(KeyType::X25519),
            21 => ::std::option::Option::Some(KeyType::X25519_PUBLIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KeyType] = &[
            KeyType::UNKNOWN_KEY_TYPE,
            KeyType::EDX25519,
            KeyType::EDX25519_PUBLIC,
            KeyType::X25519,
            KeyType::X25519_PUBLIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<KeyType>("KeyType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for KeyType {
}

impl ::std::default::Default for KeyType {
    fn default() -> Self {
        KeyType::UNKNOWN_KEY_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SortDirection {
    ASC = 0,
    DESC = 1,
}

impl ::protobuf::ProtobufEnum for SortDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SortDirection> {
        match value {
            0 => ::std::option::Option::Some(SortDirection::ASC),
            1 => ::std::option::Option::Some(SortDirection::DESC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SortDirection] = &[
            SortDirection::ASC,
            SortDirection::DESC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SortDirection>("SortDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SortDirection {
}

impl ::std::default::Default for SortDirection {
    fn default() -> Self {
        SortDirection::ASC
    }
}

impl ::protobuf::reflect::ProtobufValue for SortDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SecretType {
    UNKNOWN_SECRET_TYPE = 0,
    PASSWORD_SECRET = 10,
    CONTACT_SECRET = 11,
    CARD_SECRET = 12,
    NOTE_SECRET = 13,
}

impl ::protobuf::ProtobufEnum for SecretType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SecretType> {
        match value {
            0 => ::std::option::Option::Some(SecretType::UNKNOWN_SECRET_TYPE),
            10 => ::std::option::Option::Some(SecretType::PASSWORD_SECRET),
            11 => ::std::option::Option::Some(SecretType::CONTACT_SECRET),
            12 => ::std::option::Option::Some(SecretType::CARD_SECRET),
            13 => ::std::option::Option::Some(SecretType::NOTE_SECRET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SecretType] = &[
            SecretType::UNKNOWN_SECRET_TYPE,
            SecretType::PASSWORD_SECRET,
            SecretType::CONTACT_SECRET,
            SecretType::CARD_SECRET,
            SecretType::NOTE_SECRET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SecretType>("SecretType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SecretType {
}

impl ::std::default::Default for SecretType {
    fn default() -> Self {
        SecretType::UNKNOWN_SECRET_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Encoding {
    HEX = 0,
    BASE62 = 1,
    BASE58 = 2,
    BASE32 = 3,
    BASE16 = 4,
    BASE64 = 5,
    SALTPACK = 6,
    BIP39 = 7,
}

impl ::protobuf::ProtobufEnum for Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Encoding> {
        match value {
            0 => ::std::option::Option::Some(Encoding::HEX),
            1 => ::std::option::Option::Some(Encoding::BASE62),
            2 => ::std::option::Option::Some(Encoding::BASE58),
            3 => ::std::option::Option::Some(Encoding::BASE32),
            4 => ::std::option::Option::Some(Encoding::BASE16),
            5 => ::std::option::Option::Some(Encoding::BASE64),
            6 => ::std::option::Option::Some(Encoding::SALTPACK),
            7 => ::std::option::Option::Some(Encoding::BIP39),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Encoding] = &[
            Encoding::HEX,
            Encoding::BASE62,
            Encoding::BASE58,
            Encoding::BASE32,
            Encoding::BASE16,
            Encoding::BASE64,
            Encoding::SALTPACK,
            Encoding::BIP39,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Encoding>("Encoding", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Encoding {
}

impl ::std::default::Default for Encoding {
    fn default() -> Self {
        Encoding::HEX
    }
}

impl ::protobuf::reflect::ProtobufValue for Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserStatus {
    USER_UNKNOWN = 0,
    USER_OK = 1,
    USER_RESOURCE_NOT_FOUND = 20,
    USER_CONTENT_NOT_FOUND = 30,
    USER_CONTENT_INVALID = 31,
    USER_CONN_FAILURE = 40,
    USER_FAILURE = 50,
}

impl ::protobuf::ProtobufEnum for UserStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserStatus> {
        match value {
            0 => ::std::option::Option::Some(UserStatus::USER_UNKNOWN),
            1 => ::std::option::Option::Some(UserStatus::USER_OK),
            20 => ::std::option::Option::Some(UserStatus::USER_RESOURCE_NOT_FOUND),
            30 => ::std::option::Option::Some(UserStatus::USER_CONTENT_NOT_FOUND),
            31 => ::std::option::Option::Some(UserStatus::USER_CONTENT_INVALID),
            40 => ::std::option::Option::Some(UserStatus::USER_CONN_FAILURE),
            50 => ::std::option::Option::Some(UserStatus::USER_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserStatus] = &[
            UserStatus::USER_UNKNOWN,
            UserStatus::USER_OK,
            UserStatus::USER_RESOURCE_NOT_FOUND,
            UserStatus::USER_CONTENT_NOT_FOUND,
            UserStatus::USER_CONTENT_INVALID,
            UserStatus::USER_CONN_FAILURE,
            UserStatus::USER_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<UserStatus>("UserStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UserStatus {
}

impl ::std::default::Default for UserStatus {
    fn default() -> Self {
        UserStatus::USER_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WatchStatus {
    WATCH_UKNOWN = 0,
    WATCH_OUTAGE = 12,
    WATCH_DISRUPTED = 13,
    WATCH_STARTING = 14,
    WATCH_DATA = 16,
}

impl ::protobuf::ProtobufEnum for WatchStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WatchStatus> {
        match value {
            0 => ::std::option::Option::Some(WatchStatus::WATCH_UKNOWN),
            12 => ::std::option::Option::Some(WatchStatus::WATCH_OUTAGE),
            13 => ::std::option::Option::Some(WatchStatus::WATCH_DISRUPTED),
            14 => ::std::option::Option::Some(WatchStatus::WATCH_STARTING),
            16 => ::std::option::Option::Some(WatchStatus::WATCH_DATA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WatchStatus] = &[
            WatchStatus::WATCH_UKNOWN,
            WatchStatus::WATCH_OUTAGE,
            WatchStatus::WATCH_DISRUPTED,
            WatchStatus::WATCH_STARTING,
            WatchStatus::WATCH_DATA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<WatchStatus>("WatchStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WatchStatus {
}

impl ::std::default::Default for WatchStatus {
    fn default() -> Self {
        WatchStatus::WATCH_UKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrefKey {
    PREF_UNKNOWN = 0,
}

impl ::protobuf::ProtobufEnum for PrefKey {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrefKey> {
        match value {
            0 => ::std::option::Option::Some(PrefKey::PREF_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrefKey] = &[
            PrefKey::PREF_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PrefKey>("PrefKey", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PrefKey {
}

impl ::std::default::Default for PrefKey {
    fn default() -> Self {
        PrefKey::PREF_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WormholeStatus {
    WORMHOLE_DEFAULT = 0,
    WORMHOLE_STARTING = 10,
    WORMHOLE_OFFERING = 20,
    WORMHOLE_ANSWERING = 21,
    WORMHOLE_HANDSHAKE = 40,
    WORMHOLE_CONNECTED = 100,
    WORMHOLE_CLOSED = 200,
}

impl ::protobuf::ProtobufEnum for WormholeStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WormholeStatus> {
        match value {
            0 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_DEFAULT),
            10 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_STARTING),
            20 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_OFFERING),
            21 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_ANSWERING),
            40 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_HANDSHAKE),
            100 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_CONNECTED),
            200 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WormholeStatus] = &[
            WormholeStatus::WORMHOLE_DEFAULT,
            WormholeStatus::WORMHOLE_STARTING,
            WormholeStatus::WORMHOLE_OFFERING,
            WormholeStatus::WORMHOLE_ANSWERING,
            WormholeStatus::WORMHOLE_HANDSHAKE,
            WormholeStatus::WORMHOLE_CONNECTED,
            WormholeStatus::WORMHOLE_CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<WormholeStatus>("WormholeStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WormholeStatus {
}

impl ::std::default::Default for WormholeStatus {
    fn default() -> Self {
        WormholeStatus::WORMHOLE_DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContentType {
    BINARY_CONTENT = 0,
    UTF8_CONTENT = 1,
}

impl ::protobuf::ProtobufEnum for ContentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentType> {
        match value {
            0 => ::std::option::Option::Some(ContentType::BINARY_CONTENT),
            1 => ::std::option::Option::Some(ContentType::UTF8_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContentType] = &[
            ContentType::BINARY_CONTENT,
            ContentType::UTF8_CONTENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContentType>("ContentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContentType {
}

impl ::std::default::Default for ContentType {
    fn default() -> Self {
        ContentType::BINARY_CONTENT
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageType {
    MESSAGE_SENT = 0,
    MESSAGE_PENDING = 1,
    MESSAGE_ACK = 2,
}

impl ::protobuf::ProtobufEnum for MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            0 => ::std::option::Option::Some(MessageType::MESSAGE_SENT),
            1 => ::std::option::Option::Some(MessageType::MESSAGE_PENDING),
            2 => ::std::option::Option::Some(MessageType::MESSAGE_ACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageType] = &[
            MessageType::MESSAGE_SENT,
            MessageType::MESSAGE_PENDING,
            MessageType::MESSAGE_ACK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<MessageType>("MessageType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageType {
}

impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::MESSAGE_SENT
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10proto/keys.proto\x12\x07service\x1a\x14gogoproto/gogo.proto\"R\n\
    \x08RPCError\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\x12\x18\n\x07details\x18\x03\
    \x20\x01(\tR\x07details\"o\n\x0bSignRequest\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\x12\x16\n\x06signer\x18\x05\x20\x01(\tR\x06signer\
    \x12\x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\x12\x1a\n\x08detach\
    ed\x18\x0b\x20\x01(\x08R\x08detached\"=\n\x0cSignResponse\x12\x12\n\x04d\
    ata\x18\x01\x20\x01(\x0cR\x04data\x12\x19\n\x03kid\x18\x02\x20\x01(\tR\
    \x03kidB\x07\xe2\xde\x1f\x03KID\"\x7f\n\rSignFileInput\x12\x0e\n\x02in\
    \x18\x01\x20\x01(\tR\x02in\x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\
    \x12\x16\n\x06signer\x18\x05\x20\x01(\tR\x06signer\x12\x18\n\x07armored\
    \x18\n\x20\x01(\x08R\x07armored\x12\x1a\n\x08detached\x18\x0b\x20\x01(\
    \x08R\x08detached\"W\n\x0eSignFileOutput\x12\x19\n\x03kid\x18\x01\x20\
    \x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x14\n\x05bytes\x18\x02\x20\
    \x01(\x05R\x05bytes\x12\x14\n\x05total\x18\x03\x20\x01(\x05R\x05total\"Y\
    \n\rVerifyRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\
    \x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\x12\x1a\n\x08detached\
    \x18\x0b\x20\x01(\x08R\x08detached\"J\n\x0eVerifyResponse\x12\x12\n\x04d\
    ata\x18\x01\x20\x01(\x0cR\x04data\x12$\n\x06signer\x18\x02\x20\x01(\x0b2\
    \x0c.service.KeyR\x06signer\"W\n\x15VerifyDetachedRequest\x12\x12\n\x04d\
    ata\x18\x01\x20\x01(\x0cR\x04data\x12\x10\n\x03sig\x18\x02\x20\x01(\x0cR\
    \x03sig\x12\x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\">\n\x16Veri\
    fyDetachedResponse\x12$\n\x06signer\x18\x01\x20\x01(\x0b2\x0c.service.Ke\
    yR\x06signer\"!\n\x0bVerifyInput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\"H\n\x0cVerifyOutput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12$\n\x06signer\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sign\
    er\"M\n\x0fVerifyFileInput\x12\x0e\n\x02in\x18\x01\x20\x01(\tR\x02in\x12\
    \x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x18\n\x07armored\x18\n\x20\
    \x01(\x08R\x07armored\"J\n\x10VerifyFileOutput\x12$\n\x06signer\x18\x01\
    \x20\x01(\x0b2\x0c.service.KeyR\x06signer\x12\x10\n\x03out\x18\x02\x20\
    \x01(\tR\x03out\"U\n\x17VerifyDetachedFileInput\x12\x0e\n\x02in\x18\x01\
    \x20\x01(\tR\x02in\x12\x10\n\x03sig\x18\x02\x20\x01(\x0cR\x03sig\x12\x18\
    \n\x07armored\x18\n\x20\x01(\x08R\x07armored\"U\n\x13VerifyDetachedInput\
    \x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x10\n\x03sig\x18\
    \x02\x20\x01(\x0cR\x03sig\x12\x18\n\x07armored\x18\n\x20\x01(\x08R\x07ar\
    mored\"\xbc\x01\n\tStatement\x12\x10\n\x03sig\x18\x01\x20\x01(\x0cR\x03s\
    ig\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x19\n\x03kid\x18\
    \x03\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x10\n\x03seq\x18\x04\
    \x20\x01(\x05R\x03seq\x12\x12\n\x04prev\x18\x05\x20\x01(\x0cR\x04prev\
    \x12\x16\n\x06revoke\x18\x06\x20\x01(\x05R\x06revoke\x12\x1c\n\ttimestam\
    p\x18\x07\x20\x01(\x03R\ttimestamp\x12\x12\n\x04type\x18\x08\x20\x01(\tR\
    \x04type\",\n\x0fSigchainRequest\x12\x19\n\x03kid\x18\x01\x20\x01(\tR\
    \x03kidB\x07\xe2\xde\x1f\x03KID\"f\n\x10SigchainResponse\x12\x1e\n\x03ke\
    y\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\x03key\x122\n\nstatements\x18\
    \x02\x20\x03(\x0b2\x12.service.StatementR\nstatements\"?\n\x10StatementR\
    equest\x12\x19\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03K\
    ID\x12\x10\n\x03seq\x18\x02\x20\x01(\x05R\x03seq\"E\n\x11StatementRespon\
    se\x120\n\tstatement\x18\x01\x20\x01(\x0b2\x12.service.StatementR\tstate\
    ment\"]\n\x16StatementCreateRequest\x12\x12\n\x04data\x18\x01\x20\x01(\
    \x0cR\x04data\x12\x19\n\x03kid\x18\x02\x20\x01(\tR\x03kidB\x07\xe2\xde\
    \x1f\x03KID\x12\x14\n\x05local\x18\x05\x20\x01(\x08R\x05local\"K\n\x17St\
    atementCreateResponse\x120\n\tstatement\x18\x01\x20\x01(\x0b2\x12.servic\
    e.StatementR\tstatement\"[\n\x16StatementRevokeRequest\x12\x10\n\x03seq\
    \x18\x01\x20\x01(\x05R\x03seq\x12\x19\n\x03kid\x18\x02\x20\x01(\tR\x03ki\
    dB\x07\xe2\xde\x1f\x03KID\x12\x14\n\x05local\x18\x05\x20\x01(\x08R\x05lo\
    cal\"K\n\x17StatementRevokeResponse\x120\n\tstatement\x18\x01\x20\x01(\
    \x0b2\x12.service.StatementR\tstatement\"\x8f\x01\n\tSignInput\x12\x12\n\
    \x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x0e\n\x02in\x18\x02\x20\x01(\
    \tR\x02in\x12\x10\n\x03out\x18\x03\x20\x01(\tR\x03out\x12\x16\n\x06signe\
    r\x18\x05\x20\x01(\tR\x06signer\x12\x18\n\x07armored\x18\n\x20\x01(\x08R\
    \x07armored\x12\x1a\n\x08detached\x18\x0b\x20\x01(\x08R\x08detached\";\n\
    \nSignOutput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x19\n\
    \x03kid\x18\x02\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\"\xa0\x01\n\
    \x0eEncryptRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\
    \x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\x12\x1e\n\nrecipients\
    \x18\x0b\x20\x03(\tR\nrecipients\x12\x16\n\x06sender\x18\x0c\x20\x01(\tR\
    \x06sender\x12(\n\x04mode\x18\r\x20\x01(\x0e2\x14.service.EncryptModeR\
    \x04mode\"%\n\x0fEncryptResponse\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\"\xb0\x01\n\x10EncryptFileInput\x12\x0e\n\x02in\x18\x01\x20\x01\
    (\tR\x02in\x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x18\n\x07armo\
    red\x18\n\x20\x01(\x08R\x07armored\x12\x1e\n\nrecipients\x18\x0b\x20\x03\
    (\tR\nrecipients\x12\x16\n\x06sender\x18\x0c\x20\x01(\tR\x06sender\x12(\
    \n\x04mode\x18\r\x20\x01(\x0e2\x14.service.EncryptModeR\x04mode\"?\n\x11\
    EncryptFileOutput\x12\x14\n\x05bytes\x18\x01\x20\x01(\x05R\x05bytes\x12\
    \x14\n\x05total\x18\x02\x20\x01(\x05R\x05total\"\x9e\x01\n\x0cEncryptInp\
    ut\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x18\n\x07armored\
    \x18\x02\x20\x01(\x08R\x07armored\x12\x1e\n\nrecipients\x18\x03\x20\x03(\
    \tR\nrecipients\x12\x16\n\x06sender\x18\x04\x20\x01(\tR\x06sender\x12(\n\
    \x04mode\x18\x05\x20\x01(\x0e2\x14.service.EncryptModeR\x04mode\"#\n\rEn\
    cryptOutput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"h\n\x0eDecr\
    yptRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x18\n\x07\
    armored\x18\n\x20\x01(\x08R\x07armored\x12(\n\x04mode\x18\r\x20\x01(\x0e\
    2\x14.service.EncryptModeR\x04mode\"K\n\x0fDecryptResponse\x12\x12\n\x04\
    data\x18\x01\x20\x01(\x0cR\x04data\x12$\n\x06sender\x18\x02\x20\x01(\x0b\
    2\x0c.service.KeyR\x06sender\"x\n\x10DecryptFileInput\x12\x0e\n\x02in\
    \x18\x01\x20\x01(\tR\x02in\x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\
    \x12\x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\x12(\n\x04mode\x18\
    \r\x20\x01(\x0e2\x14.service.EncryptModeR\x04mode\"w\n\x11DecryptFileOut\
    put\x12$\n\x06sender\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\x06sender\
    \x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x14\n\x05bytes\x18\x03\
    \x20\x01(\x05R\x05bytes\x12\x14\n\x05total\x18\x04\x20\x01(\x05R\x05tota\
    l\"\"\n\x0cDecryptInput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\
    \"I\n\rDecryptOutput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\
    $\n\x06sender\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sender\"\x16\n\
    \x14RuntimeStatusRequest\"\xa8\x01\n\x15RuntimeStatusResponse\x12\x18\n\
    \x07version\x18\x01\x20\x01(\tR\x07version\x12\x18\n\x07appName\x18\x02\
    \x20\x01(\tR\x07appName\x12\x10\n\x03exe\x18\x04\x20\x01(\tR\x03exe\x12(\
    \n\x0fauthSetupNeeded\x18\x05\x20\x01(\x08R\x0fauthSetupNeeded\x12\x1f\n\
    \x05fido2\x18\x06\x20\x01(\x08R\x05fido2B\t\xe2\xde\x1f\x05FIDO2\"F\n\
    \x10AuthSetupRequest\x12\x1a\n\x08password\x18\x01\x20\x01(\tR\x08passwo\
    rd\x12\x16\n\x06client\x18\x06\x20\x01(\tR\x06client\"1\n\x11AuthSetupRe\
    sponse\x12\x1c\n\tauthToken\x18\x01\x20\x01(\tR\tauthToken\"G\n\x11AuthU\
    nlockRequest\x12\x1a\n\x08password\x18\x01\x20\x01(\tR\x08password\x12\
    \x16\n\x06client\x18\x02\x20\x01(\tR\x06client\"2\n\x12AuthUnlockRespons\
    e\x12\x1c\n\tauthToken\x18\x01\x20\x01(\tR\tauthToken\"\x11\n\x0fAuthLoc\
    kRequest\"\x12\n\x10AuthLockResponse\":\n\x12KeyGenerateRequest\x12$\n\
    \x04type\x18\x01\x20\x01(\x0e2\x10.service.KeyTypeR\x04type\"0\n\x13KeyG\
    enerateResponse\x12\x19\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\x07\xe2\xde\
    \x1f\x03KID\"I\n\x12UserServiceRequest\x12\x19\n\x03kid\x18\x01\x20\x01(\
    \tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x18\n\x07service\x18\x02\x20\x01(\
    \tR\x07service\"/\n\x13UserServiceResponse\x12\x18\n\x07service\x18\x01\
    \x20\x01(\tR\x07service\"Z\n\x0fUserSignRequest\x12\x19\n\x03kid\x18\x01\
    \x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x18\n\x07service\x18\x02\
    \x20\x01(\tR\x07service\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"@\
    \n\x10UserSignResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messa\
    ge\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\x8a\x01\n\x0eUserAddR\
    equest\x12\x19\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03K\
    ID\x12\x18\n\x07service\x18\x02\x20\x01(\tR\x07service\x12\x12\n\x04name\
    \x18\x03\x20\x01(\tR\x04name\x12\x19\n\x03url\x18\x04\x20\x01(\tR\x03url\
    B\x07\xe2\xde\x1f\x03URL\x12\x14\n\x05local\x18\x05\x20\x01(\x08R\x05loc\
    al\"f\n\x0fUserAddResponse\x12!\n\x04user\x18\x01\x20\x01(\x0b2\r.servic\
    e.UserR\x04user\x120\n\tstatement\x18\x02\x20\x01(\x0b2\x12.service.Stat\
    ementR\tstatement\"r\n\x10KeyExportRequest\x12\x19\n\x03kid\x18\x01\x20\
    \x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x1a\n\x08password\x18\x02\
    \x20\x01(\tR\x08password\x12'\n\x04type\x18\x03\x20\x01(\x0e2\x13.servic\
    e.ExportTypeR\x04type\"+\n\x11KeyExportResponse\x12\x16\n\x06export\x18\
    \x01\x20\x01(\x0cR\x06export\">\n\x10KeyImportRequest\x12\x0e\n\x02in\
    \x18\x01\x20\x01(\x0cR\x02in\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\
    \x08password\".\n\x11KeyImportResponse\x12\x19\n\x03kid\x18\x01\x20\x01(\
    \tR\x03kidB\x07\xe2\xde\x1f\x03KID\"-\n\x10KeyRemoveRequest\x12\x19\n\
    \x03kid\x18\x01\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\"\x13\n\x11Ke\
    yRemoveResponse\"\xd2\x01\n\x03Key\x12\x16\n\x02id\x18\x01\x20\x01(\tR\
    \x02idB\x06\xe2\xde\x1f\x02ID\x12$\n\x04type\x18\x03\x20\x01(\x0e2\x10.s\
    ervice.KeyTypeR\x04type\x12!\n\x04user\x18\x06\x20\x01(\x0b2\r.service.U\
    serR\x04user\x12\x14\n\x05saved\x18\n\x20\x01(\x08R\x05saved\x12&\n\x0es\
    igchainLength\x18(\x20\x01(\x05R\x0esigchainLength\x12,\n\x11sigchainUpd\
    atedAt\x18)\x20\x01(\x03R\x11sigchainUpdatedAt\"@\n\nKeyRequest\x12\x1a\
    \n\x08identity\x18\x01\x20\x01(\tR\x08identity\x12\x16\n\x06update\x18\
    \x05\x20\x01(\x08R\x06update\"-\n\x0bKeyResponse\x12\x1e\n\x03key\x18\
    \x01\x20\x01(\x0b2\x0c.service.KeyR\x03key\"\xa7\x01\n\x0bKeysRequest\
    \x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x12&\n\x05types\x18\x02\
    \x20\x03(\x0e2\x10.service.KeyTypeR\x05types\x12\x1c\n\tsortField\x18\n\
    \x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\x0b\x20\x01(\x0e2\x16.\
    service.SortDirectionR\rsortDirection\"\x8c\x01\n\x0cKeysResponse\x12\
    \x20\n\x04keys\x18\x01\x20\x03(\x0b2\x0c.service.KeyR\x04keys\x12\x1c\n\
    \tsortField\x18\n\x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\x0b\
    \x20\x01(\x0e2\x16.service.SortDirectionR\rsortDirection\"\x82\x02\n\x06\
    Secret\x12\x16\n\x02id\x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\x02ID\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12'\n\x04type\x18\x03\
    \x20\x01(\x0e2\x13.service.SecretTypeR\x04type\x12\x1a\n\x08username\x18\
    \n\x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\x0b\x20\x01(\tR\x08\
    password\x12\x19\n\x03url\x18\x14\x20\x01(\tR\x03urlB\x07\xe2\xde\x1f\
    \x03URL\x12\x14\n\x05notes\x18\x1e\x20\x01(\tR\x05notes\x12\x1c\n\tcreat\
    edAt\x18d\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18e\x20\x01(\
    \x03R\tupdatedAt\"'\n\rSecretRequest\x12\x16\n\x02id\x18\x01\x20\x01(\tR\
    \x02idB\x06\xe2\xde\x1f\x02ID\"9\n\x0eSecretResponse\x12'\n\x06secret\
    \x18\x01\x20\x01(\x0b2\x0f.service.SecretR\x06secret\"<\n\x11SecretSaveR\
    equest\x12'\n\x06secret\x18\x01\x20\x01(\x0b2\x0f.service.SecretR\x06sec\
    ret\"=\n\x12SecretSaveResponse\x12'\n\x06secret\x18\x01\x20\x01(\x0b2\
    \x0f.service.SecretR\x06secret\"-\n\x13SecretRemoveRequest\x12\x16\n\x02\
    id\x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\x02ID\"\x16\n\x14SecretRem\
    oveResponse\"\x82\x01\n\x0eSecretsRequest\x12\x14\n\x05query\x18\x01\x20\
    \x01(\tR\x05query\x12\x1c\n\tsortField\x18\n\x20\x01(\tR\tsortField\x12<\
    \n\rsortDirection\x18\x0b\x20\x01(\x0e2\x16.service.SortDirectionR\rsort\
    Direction\"\x98\x01\n\x0fSecretsResponse\x12)\n\x07secrets\x18\x01\x20\
    \x03(\x0b2\x0f.service.SecretR\x07secrets\x12\x1c\n\tsortField\x18\n\x20\
    \x01(\tR\tsortField\x12<\n\rsortDirection\x18\x0b\x20\x01(\x0e2\x16.serv\
    ice.SortDirectionR\rsortDirection\"%\n\x0bItemRequest\x12\x16\n\x02id\
    \x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\x02ID\"1\n\x0cItemResponse\
    \x12!\n\x04item\x18\x01\x20\x01(\x0b2\r.service.ItemR\x04item\"$\n\x0cIt\
    emsRequest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"4\n\rItemsRe\
    sponse\x12#\n\x05items\x18\x01\x20\x03(\x0b2\r.service.ItemR\x05items\"2\
    \n\x04Item\x12\x16\n\x02id\x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\
    \x02ID\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\"X\n\x0bRandRequest\
    \x12\x1a\n\x08numBytes\x18\x01\x20\x01(\x05R\x08numBytes\x12-\n\x08encod\
    ing\x18\x02\x20\x01(\x0e2\x11.service.EncodingR\x08encoding\"\"\n\x0cRan\
    dResponse\x12\x12\n\x04data\x18\x01\x20\x01(\tR\x04data\"-\n\x13RandPass\
    wordRequest\x12\x16\n\x06length\x18\x01\x20\x01(\x05R\x06length\"2\n\x14\
    RandPasswordResponse\x12\x1a\n\x08password\x18\x01\x20\x01(\tR\x08passwo\
    rd\")\n\x0bPullRequest\x12\x1a\n\x08identity\x18\x01\x20\x01(\tR\x08iden\
    tity\",\n\x0cPullResponse\x12\x1c\n\x04kids\x18\x01\x20\x03(\tR\x04kidsB\
    \x08\xe2\xde\x1f\x04KIDs\"K\n\x0bPushRequest\x12\x1a\n\x08identity\x18\
    \x01\x20\x01(\tR\x08identity\x12\x20\n\x0bremoteCheck\x18\x02\x20\x01(\
    \x08R\x0bremoteCheck\"G\n\x0cPushResponse\x12\x19\n\x03kid\x18\x01\x20\
    \x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x1c\n\x04urls\x18\x02\x20\
    \x03(\tR\x04urlsB\x08\xe2\xde\x1f\x04URLs\"\x20\n\nCollection\x12\x12\n\
    \x04path\x18\x01\x20\x01(\tR\x04path\"(\n\x12CollectionsRequest\x12\x12\
    \n\x04path\x18\x01\x20\x01(\tR\x04path\"L\n\x13CollectionsResponse\x125\
    \n\x0bcollections\x18\x01\x20\x03(\x0b2\x13.service.CollectionR\x0bcolle\
    ctions\"p\n\x08Document\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x1c\n\tcreatedAt\
    \x18\n\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18\x0b\x20\x01(\
    \x03R\tupdatedAt\">\n\x10DocumentsRequest\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12\x16\n\x06prefix\x18\x02\x20\x01(\tR\x06prefix\"D\n\
    \x11DocumentsResponse\x12/\n\tdocuments\x18\x01\x20\x03(\x0b2\x11.servic\
    e.DocumentR\tdocuments\"+\n\x15DocumentDeleteRequest\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\"\x18\n\x16DocumentDeleteResponse\"\x91\x02\
    \n\x04User\x12\x16\n\x02id\x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\
    \x02ID\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x19\n\x03kid\
    \x18\x03\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\x12\x10\n\x03seq\x18\
    \x04\x20\x01(\x05R\x03seq\x12\x18\n\x07service\x18\x05\x20\x01(\tR\x07se\
    rvice\x12\x19\n\x03url\x18\x06\x20\x01(\tR\x03urlB\x07\xe2\xde\x1f\x03UR\
    L\x12+\n\x06status\x18\n\x20\x01(\x0e2\x13.service.UserStatusR\x06status\
    \x12\x1e\n\nverifiedAt\x18\x0b\x20\x01(\x03R\nverifiedAt\x12\x1c\n\ttime\
    stamp\x18\x0c\x20\x01(\x03R\ttimestamp\x12\x10\n\x03err\x18\x14\x20\x01(\
    \tR\x03err\">\n\x0bUserRequest\x12\x19\n\x03kid\x18\x01\x20\x01(\tR\x03k\
    idB\x07\xe2\xde\x1f\x03KID\x12\x14\n\x05local\x18\x04\x20\x01(\x08R\x05l\
    ocal\"1\n\x0cUserResponse\x12!\n\x04user\x18\x01\x20\x01(\x0b2\r.service\
    .UserR\x04user\"U\n\x11UserSearchRequest\x12\x14\n\x05query\x18\x01\x20\
    \x01(\tR\x05query\x12\x14\n\x05limit\x18\x03\x20\x01(\x05R\x05limit\x12\
    \x14\n\x05local\x18\x04\x20\x01(\x08R\x05local\"9\n\x12UserSearchRespons\
    e\x12#\n\x05users\x18\x01\x20\x03(\x0b2\r.service.UserR\x05users\"%\n\rS\
    earchRequest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"2\n\x0eSea\
    rchResponse\x12\x20\n\x04keys\x18\x01\x20\x03(\x0b2\x0c.service.KeyR\x04\
    keys\"\x0e\n\x0cWatchRequest\"N\n\nWatchEvent\x12,\n\x06status\x18\x01\
    \x20\x01(\x0e2\x14.service.WatchStatusR\x06status\x12\x12\n\x04path\x18\
    \x02\x20\x01(\tR\x04path\".\n\x04Pref\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x14\n\x12Pr\
    eferencesRequest\":\n\x13PreferencesResponse\x12#\n\x05prefs\x18\x01\x20\
    \x03(\x0b2\r.service.PrefR\x05prefs\"9\n\x14PreferenceSetRequest\x12!\n\
    \x04pref\x18\x01\x20\x01(\x0b2\r.service.PrefR\x04pref\"\x17\n\x15Prefer\
    enceSetResponse\"\xb3\x01\n\rWormholeInput\x12\x16\n\x06sender\x18\x01\
    \x20\x01(\tR\x06sender\x12\x1c\n\trecipient\x18\x02\x20\x01(\tR\trecipie\
    nt\x12\x16\n\x06invite\x18\x03\x20\x01(\tR\x06invite\x12\x16\n\x02id\x18\
    \n\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\x02ID\x12\x12\n\x04data\x18\x0b\
    \x20\x01(\x0cR\x04data\x12(\n\x04type\x18\x0c\x20\x01(\x0e2\x14.service.\
    ContentTypeR\x04type\"m\n\x0eWormholeOutput\x12*\n\x07message\x18\x01\
    \x20\x01(\x0b2\x10.service.MessageR\x07message\x12/\n\x06status\x18\x02\
    \x20\x01(\x0e2\x17.service.WormholeStatusR\x06status\"\xab\x02\n\x07Mess\
    age\x12\x16\n\x02id\x18\x01\x20\x01(\tR\x02idB\x06\xe2\xde\x1f\x02ID\x12\
    $\n\x06sender\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sender\x12*\n\tr\
    ecipient\x18\x03\x20\x01(\x0b2\x0c.service.KeyR\trecipient\x12(\n\x04typ\
    e\x18\x05\x20\x01(\x0e2\x14.service.MessageTypeR\x04type\x12*\n\x07conte\
    nt\x18\n\x20\x01(\x0b2\x10.service.ContentR\x07content\x12\x1c\n\tcreate\
    dAt\x18\x15\x20\x01(\x03R\tcreatedAt\x12\x20\n\x0btimeDisplay\x18\x1f\
    \x20\x01(\tR\x0btimeDisplay\x12\x20\n\x0bdateDisplay\x18\x20\x20\x01(\tR\
    \x0bdateDisplay\"G\n\x07Content\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12(\n\x04type\x18\x02\x20\x01(\x0e2\x14.service.ContentTypeR\
    \x04type\"a\n\x15MessagePrepareRequest\x12\x16\n\x06sender\x18\x01\x20\
    \x01(\tR\x06sender\x12\x1c\n\trecipient\x18\x02\x20\x01(\tR\trecipient\
    \x12\x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"D\n\x16MessagePrepareRes\
    ponse\x12*\n\x07message\x18\x01\x20\x01(\x0b2\x10.service.MessageR\x07me\
    ssage\"`\n\x14MessageCreateRequest\x12\x16\n\x06sender\x18\x01\x20\x01(\
    \tR\x06sender\x12\x1c\n\trecipient\x18\x02\x20\x01(\tR\trecipient\x12\
    \x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"C\n\x15MessageCreateResponse\
    \x12*\n\x07message\x18\x01\x20\x01(\x0b2\x10.service.MessageR\x07message\
    \"G\n\x0fMessagesRequest\x12\x16\n\x06sender\x18\x01\x20\x01(\tR\x06send\
    er\x12\x1c\n\trecipient\x18\x02\x20\x01(\tR\trecipient\"@\n\x10MessagesR\
    esponse\x12,\n\x08messages\x18\x01\x20\x03(\x0b2\x10.service.MessageR\
    \x08messages\"`\n\x13AdminSignURLRequest\x12\x16\n\x06signer\x18\x01\x20\
    \x01(\tR\x06signer\x12\x16\n\x06method\x18\x02\x20\x01(\tR\x06method\x12\
    \x19\n\x03url\x18\x03\x20\x01(\tR\x03urlB\x07\xe2\xde\x1f\x03URL\"c\n\
    \x14AdminSignURLResponse\x12\x12\n\x04auth\x18\x01\x20\x01(\tR\x04auth\
    \x12\x19\n\x03url\x18\x02\x20\x01(\tR\x03urlB\x07\xe2\xde\x1f\x03URL\x12\
    \x1c\n\x04curl\x18\x03\x20\x01(\tR\x04curlB\x08\xe2\xde\x1f\x04CURL\"F\n\
    \x11AdminCheckRequest\x12\x16\n\x06signer\x18\x01\x20\x01(\tR\x06signer\
    \x12\x19\n\x03kid\x18\x02\x20\x01(\tR\x03kidB\x07\xe2\xde\x1f\x03KID\"\
    \x14\n\x12AdminCheckResponse*\x96\x01\n\x0bEncryptMode\x120\n\x14DEFAULT\
    _ENCRYPT_MODE\x10\0\x1a\x16\x8a\x9d\x20\x12DefaultEncryptMode\x12\x1d\n\
    \nENCRYPT_V2\x10\x01\x1a\r\x8a\x9d\x20\tEncryptV2\x12!\n\x0cSIGNCRYPT_V1\
    \x10\x02\x1a\x0f\x8a\x9d\x20\x0bSigncryptV1\x1a\x13\xba\xa4\x1e\x0bEncry\
    ptMode\x88\xa3\x1e\0*\x82\x01\n\nExportType\x12.\n\x13DEFAULT_EXPORT_TYP\
    E\x10\0\x1a\x15\x8a\x9d\x20\x11DefaultExportType\x120\n\x14SALTPACK_EXPO\
    RT_TYPE\x10\x01\x1a\x16\x8a\x9d\x20\x12SaltpackExportType\x1a\x12\x88\
    \xa3\x1e\0\xba\xa4\x1e\nExportType*\xc6\x01\n\x07KeyType\x12(\n\x10UNKNO\
    WN_KEY_TYPE\x10\0\x1a\x12\x8a\x9d\x20\x0eUnknownKeyType\x12\x1a\n\x08EDX\
    25519\x10\n\x1a\x0c\x8a\x9d\x20\x08EdX25519\x12'\n\x0fEDX25519_PUBLIC\
    \x10\x0b\x1a\x12\x8a\x9d\x20\x0eEdX25519Public\x12\x16\n\x06X25519\x10\
    \x14\x1a\n\x8a\x9d\x20\x06X25519\x12#\n\rX25519_PUBLIC\x10\x15\x1a\x10\
    \x8a\x9d\x20\x0cX25519Public\x1a\x0f\xba\xa4\x1e\x07KeyType\x88\xa3\x1e\
    \0*T\n\rSortDirection\x12\x14\n\x03ASC\x10\0\x1a\x0b\x8a\x9d\x20\x07Sort\
    Asc\x12\x16\n\x04DESC\x10\x01\x1a\x0c\x8a\x9d\x20\x08SortDesc\x1a\x15\
    \x88\xa3\x1e\0\xba\xa4\x1e\rSortDirection*\xde\x01\n\nSecretType\x12*\n\
    \x13UNKNOWN_SECRET_TYPE\x10\0\x1a\x11\x8a\x9d\x20\rUnknownSecret\x12'\n\
    \x0fPASSWORD_SECRET\x10\n\x1a\x12\x8a\x9d\x20\x0ePasswordSecret\x12%\n\
    \x0eCONTACT_SECRET\x10\x0b\x1a\x11\x8a\x9d\x20\rContactSecret\x12\x1f\n\
    \x0bCARD_SECRET\x10\x0c\x1a\x0e\x8a\x9d\x20\nCardSecret\x12\x1f\n\x0bNOT\
    E_SECRET\x10\r\x1a\x0e\x8a\x9d\x20\nNoteSecret\x1a\x12\xba\xa4\x1e\nSecr\
    etType\x88\xa3\x1e\0*\xd8\x01\n\x08Encoding\x12\x10\n\x03HEX\x10\0\x1a\
    \x07\x8a\x9d\x20\x03Hex\x12\x16\n\x06BASE62\x10\x01\x1a\n\x8a\x9d\x20\
    \x06Base62\x12\x16\n\x06BASE58\x10\x02\x1a\n\x8a\x9d\x20\x06Base58\x12\
    \x16\n\x06BASE32\x10\x03\x1a\n\x8a\x9d\x20\x06Base32\x12\x16\n\x06BASE16\
    \x10\x04\x1a\n\x8a\x9d\x20\x06Base16\x12\x16\n\x06BASE64\x10\x05\x1a\n\
    \x8a\x9d\x20\x06Base64\x12\x1a\n\x08SALTPACK\x10\x06\x1a\x0c\x8a\x9d\x20\
    \x08Saltpack\x12\x14\n\x05BIP39\x10\x07\x1a\t\x8a\x9d\x20\x05BIP39\x1a\
    \x10\x88\xa3\x1e\0\xba\xa4\x1e\x08Encoding*\xf3\x02\n\nUserStatus\x12'\n\
    \x0cUSER_UNKNOWN\x10\0\x1a\x15\x8a\x9d\x20\x11UserStatusUnknown\x12\x1d\
    \n\x07USER_OK\x10\x01\x1a\x10\x8a\x9d\x20\x0cUserStatusOK\x12;\n\x17USER\
    _RESOURCE_NOT_FOUND\x10\x14\x1a\x1e\x8a\x9d\x20\x1aUserStatusResourceNot\
    Found\x129\n\x16USER_CONTENT_NOT_FOUND\x10\x1e\x1a\x1d\x8a\x9d\x20\x19Us\
    erStatusContentNotFound\x126\n\x14USER_CONTENT_INVALID\x10\x1f\x1a\x1c\
    \x8a\x9d\x20\x18UserStatusContentInvalid\x120\n\x11USER_CONN_FAILURE\x10\
    (\x1a\x19\x8a\x9d\x20\x15UserStatusConnFailure\x12'\n\x0cUSER_FAILURE\
    \x102\x1a\x15\x8a\x9d\x20\x11UserStatusFailure\x1a\x12\xba\xa4\x1e\nUser\
    Status\x88\xa3\x1e\0*\xf6\x01\n\x0bWatchStatus\x12(\n\x0cWATCH_UKNOWN\
    \x10\0\x1a\x16\x8a\x9d\x20\x12WatchStatusUnknown\x12'\n\x0cWATCH_OUTAGE\
    \x10\x0c\x1a\x15\x8a\x9d\x20\x11WatchStatusOutage\x12-\n\x0fWATCH_DISRUP\
    TED\x10\r\x1a\x18\x8a\x9d\x20\x14WatchStatusDisrupted\x12+\n\x0eWATCH_ST\
    ARTING\x10\x0e\x1a\x17\x8a\x9d\x20\x13WatchStatusStarting\x12#\n\nWATCH_\
    DATA\x10\x10\x1a\x13\x8a\x9d\x20\x0fWatchStatusData\x1a\x13\x88\xa3\x1e\
    \0\xba\xa4\x1e\x0bWatchStatus*=\n\x07PrefKey\x12!\n\x0cPREF_UNKNOWN\x10\
    \0\x1a\x0f\x8a\x9d\x20\x0bPrefUnknown\x1a\x0f\x88\xa3\x1e\0\xba\xa4\x1e\
    \x07PrefKey*\xe4\x02\n\x0eWormholeStatus\x12)\n\x10WORMHOLE_DEFAULT\x10\
    \0\x1a\x13\x8a\x9d\x20\x0fWormholeDefault\x12+\n\x11WORMHOLE_STARTING\
    \x10\n\x1a\x14\x8a\x9d\x20\x10WormholeStarting\x12+\n\x11WORMHOLE_OFFERI\
    NG\x10\x14\x1a\x14\x8a\x9d\x20\x10WormholeOffering\x12-\n\x12WORMHOLE_AN\
    SWERING\x10\x15\x1a\x15\x8a\x9d\x20\x11WormholeAnswering\x12-\n\x12WORMH\
    OLE_HANDSHAKE\x10(\x1a\x15\x8a\x9d\x20\x11WormholeHandshake\x12-\n\x12WO\
    RMHOLE_CONNECTED\x10d\x1a\x15\x8a\x9d\x20\x11WormholeConnected\x12(\n\
    \x0fWORMHOLE_CLOSED\x10\xc8\x01\x1a\x12\x8a\x9d\x20\x0eWormholeClosed\
    \x1a\x16\x88\xa3\x1e\0\xba\xa4\x1e\x0eWormholeStatus*l\n\x0bContentType\
    \x12%\n\x0eBINARY_CONTENT\x10\0\x1a\x11\x8a\x9d\x20\rBinaryContent\x12!\
    \n\x0cUTF8_CONTENT\x10\x01\x1a\x0f\x8a\x9d\x20\x0bUTF8Content\x1a\x13\
    \x88\xa3\x1e\0\xba\xa4\x1e\x0bContentType*\x8f\x01\n\x0bMessageType\x12!\
    \n\x0cMESSAGE_SENT\x10\0\x1a\x0f\x8a\x9d\x20\x0bMessageSent\x12'\n\x0fME\
    SSAGE_PENDING\x10\x01\x1a\x12\x8a\x9d\x20\x0eMessagePending\x12\x1f\n\
    \x0bMESSAGE_ACK\x10\x02\x1a\x0e\x8a\x9d\x20\nMessageAck\x1a\x13\x88\xa3\
    \x1e\0\xba\xa4\x1e\x0bMessageType2\xdc!\n\x04Keys\x12J\n\x0bKeyGenerate\
    \x12\x1b.service.KeyGenerateRequest\x1a\x1c.service.KeyGenerateResponse\
    \"\0\x125\n\x04Keys\x12\x14.service.KeysRequest\x1a\x15.service.KeysResp\
    onse\"\0\x122\n\x03Key\x12\x13.service.KeyRequest\x1a\x14.service.KeyRes\
    ponse\"\0\x12D\n\tKeyImport\x12\x19.service.KeyImportRequest\x1a\x1a.ser\
    vice.KeyImportResponse\"\0\x12D\n\tKeyExport\x12\x19.service.KeyExportRe\
    quest\x1a\x1a.service.KeyExportResponse\"\0\x12D\n\tKeyRemove\x12\x19.se\
    rvice.KeyRemoveRequest\x1a\x1a.service.KeyRemoveResponse\"\0\x125\n\x04S\
    ign\x12\x14.service.SignRequest\x1a\x15.service.SignResponse\"\0\x12A\n\
    \x08SignFile\x12\x16.service.SignFileInput\x1a\x17.service.SignFileOutpu\
    t\"\0(\x010\x01\x12;\n\nSignStream\x12\x12.service.SignInput\x1a\x13.ser\
    vice.SignOutput\"\0(\x010\x01\x12;\n\x06Verify\x12\x16.service.VerifyReq\
    uest\x1a\x17.service.VerifyResponse\"\0\x12G\n\nVerifyFile\x12\x18.servi\
    ce.VerifyFileInput\x1a\x19.service.VerifyFileOutput\"\0(\x010\x01\x12A\n\
    \x0cVerifyStream\x12\x14.service.VerifyInput\x1a\x15.service.VerifyOutpu\
    t\"\0(\x010\x01\x12H\n\x13VerifyArmoredStream\x12\x14.service.VerifyInpu\
    t\x1a\x15.service.VerifyOutput\"\0(\x010\x01\x12S\n\x0eVerifyDetached\
    \x12\x1e.service.VerifyDetachedRequest\x1a\x1f.service.VerifyDetachedRes\
    ponse\"\0\x12[\n\x12VerifyDetachedFile\x12\x20.service.VerifyDetachedFil\
    eInput\x1a\x1f.service.VerifyDetachedResponse\"\0(\x01\x12Y\n\x14VerifyD\
    etachedStream\x12\x1c.service.VerifyDetachedInput\x1a\x1f.service.Verify\
    DetachedResponse\"\0(\x01\x12>\n\x07Encrypt\x12\x17.service.EncryptReque\
    st\x1a\x18.service.EncryptResponse\"\0\x12D\n\rEncryptStream\x12\x15.ser\
    vice.EncryptInput\x1a\x16.service.EncryptOutput\"\0(\x010\x01\x12J\n\x0b\
    EncryptFile\x12\x19.service.EncryptFileInput\x1a\x1a.service.EncryptFile\
    Output\"\0(\x010\x01\x12>\n\x07Decrypt\x12\x17.service.DecryptRequest\
    \x1a\x18.service.DecryptResponse\"\0\x12J\n\x0bDecryptFile\x12\x19.servi\
    ce.DecryptFileInput\x1a\x1a.service.DecryptFileOutput\"\0(\x010\x01\x12D\
    \n\rDecryptStream\x12\x15.service.DecryptInput\x1a\x16.service.DecryptOu\
    tput\"\0(\x010\x01\x12K\n\x14DecryptArmoredStream\x12\x15.service.Decryp\
    tInput\x1a\x16.service.DecryptOutput\"\0(\x010\x01\x12J\n\x13SigncryptOp\
    enStream\x12\x15.service.DecryptInput\x1a\x16.service.DecryptOutput\"\0(\
    \x010\x01\x12Q\n\x1aSigncryptOpenArmoredStream\x12\x15.service.DecryptIn\
    put\x1a\x16.service.DecryptOutput\"\0(\x010\x01\x12A\n\x08Sigchain\x12\
    \x18.service.SigchainRequest\x1a\x19.service.SigchainResponse\"\0\x12D\n\
    \tStatement\x12\x19.service.StatementRequest\x1a\x1a.service.StatementRe\
    sponse\"\0\x12V\n\x0fStatementCreate\x12\x1f.service.StatementCreateRequ\
    est\x1a\x20.service.StatementCreateResponse\"\0\x12V\n\x0fStatementRevok\
    e\x12\x1f.service.StatementRevokeRequest\x1a\x20.service.StatementRevoke\
    Response\"\0\x125\n\x04User\x12\x14.service.UserRequest\x1a\x15.service.\
    UserResponse\"\0\x12G\n\nUserSearch\x12\x1a.service.UserSearchRequest\
    \x1a\x1b.service.UserSearchResponse\"\0\x12J\n\x0bUserService\x12\x1b.se\
    rvice.UserServiceRequest\x1a\x1c.service.UserServiceResponse\"\0\x12A\n\
    \x08UserSign\x12\x18.service.UserSignRequest\x1a\x19.service.UserSignRes\
    ponse\"\0\x12>\n\x07UserAdd\x12\x17.service.UserAddRequest\x1a\x18.servi\
    ce.UserAddResponse\"\0\x12;\n\x06Search\x12\x16.service.SearchRequest\
    \x1a\x17.service.SearchResponse\"\0\x12;\n\x06Secret\x12\x16.service.Sec\
    retRequest\x1a\x17.service.SecretResponse\"\0\x12G\n\nSecretSave\x12\x1a\
    .service.SecretSaveRequest\x1a\x1b.service.SecretSaveResponse\"\0\x12M\n\
    \x0cSecretRemove\x12\x1c.service.SecretRemoveRequest\x1a\x1d.service.Sec\
    retRemoveResponse\"\0\x12>\n\x07Secrets\x12\x17.service.SecretsRequest\
    \x1a\x18.service.SecretsResponse\"\0\x125\n\x04Item\x12\x14.service.Item\
    Request\x1a\x15.service.ItemResponse\"\0\x128\n\x05Items\x12\x15.service\
    .ItemsRequest\x1a\x16.service.ItemsResponse\"\0\x125\n\x04Pull\x12\x14.s\
    ervice.PullRequest\x1a\x15.service.PullResponse\"\0\x125\n\x04Push\x12\
    \x14.service.PushRequest\x1a\x15.service.PushResponse\"\0\x12A\n\x08Worm\
    hole\x12\x16.service.WormholeInput\x1a\x17.service.WormholeOutput\"\0(\
    \x010\x01\x12J\n\x0bPreferences\x12\x1b.service.PreferencesRequest\x1a\
    \x1c.service.PreferencesResponse\"\0\x12P\n\rPreferenceSet\x12\x1d.servi\
    ce.PreferenceSetRequest\x1a\x1e.service.PreferenceSetResponse\"\0\x12D\n\
    \tAuthSetup\x12\x19.service.AuthSetupRequest\x1a\x1a.service.AuthSetupRe\
    sponse\"\0\x12G\n\nAuthUnlock\x12\x1a.service.AuthUnlockRequest\x1a\x1b.\
    service.AuthUnlockResponse\"\0\x12A\n\x08AuthLock\x12\x18.service.AuthLo\
    ckRequest\x1a\x19.service.AuthLockResponse\"\0\x12P\n\rRuntimeStatus\x12\
    \x1d.service.RuntimeStatusRequest\x1a\x1e.service.RuntimeStatusResponse\
    \"\0\x125\n\x04Rand\x12\x14.service.RandRequest\x1a\x15.service.RandResp\
    onse\"\0\x12M\n\x0cRandPassword\x12\x1c.service.RandPasswordRequest\x1a\
    \x1d.service.RandPasswordResponse\"\0\x12J\n\x0bCollections\x12\x1b.serv\
    ice.CollectionsRequest\x1a\x1c.service.CollectionsResponse\"\0\x12D\n\tD\
    ocuments\x12\x19.service.DocumentsRequest\x1a\x1a.service.DocumentsRespo\
    nse\"\0\x12S\n\x0eDocumentDelete\x12\x1e.service.DocumentDeleteRequest\
    \x1a\x1f.service.DocumentDeleteResponse\"\0\x12M\n\x0cAdminSignURL\x12\
    \x1c.service.AdminSignURLRequest\x1a\x1d.service.AdminSignURLResponse\"\
    \0\x12G\n\nAdminCheck\x12\x1a.service.AdminCheckRequest\x1a\x1b.service.\
    AdminCheckResponse\"\0\x12S\n\x0eMessagePrepare\x12\x1e.service.MessageP\
    repareRequest\x1a\x1f.service.MessagePrepareResponse\"\0\x12P\n\rMessage\
    Create\x12\x1d.service.MessageCreateRequest\x1a\x1e.service.MessageCreat\
    eResponse\"\0\x12A\n\x08Messages\x12\x18.service.MessagesRequest\x1a\x19\
    .service.MessagesResponse\"\0\x127\n\x05Watch\x12\x15.service.WatchReque\
    st\x1a\x13.service.WatchEvent\"\00\x01B\x1c\xe0\xe2\x1e\x01\xc8\xe2\x1e\
    \x01\xd8\xe1\x1e\x01\xd0\xe2\x1e\x01\xf0\xe1\x1e\x01\xe8\xe2\x1e\x01\xc8\
    \xe1\x1e\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
